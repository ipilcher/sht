<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SHT Hash Table: src/sht.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SHT Hash Table
   </div>
   <div id="projectbrief">SHT Hash Table</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('sht_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">sht.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="sht_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad8ef9ee0703cc0982a080f184ecf5255" id="r_ad8ef9ee0703cc0982a080f184ecf5255"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8ef9ee0703cc0982a080f184ecf5255">SHT_NEW</a>(hashfn,  eqfn,  etype, ...)</td></tr>
<tr class="memdesc:ad8ef9ee0703cc0982a080f184ecf5255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new hash table.  <br /></td></tr>
<tr class="memitem:a5151d8f5358c4e8794d00175adafdf50" id="r_a5151d8f5358c4e8794d00175adafdf50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5151d8f5358c4e8794d00175adafdf50">SHT_ITER_FREE</a>(iter)</td></tr>
<tr class="memdesc:a5151d8f5358c4e8794d00175adafdf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a hash table iterator.  <br /></td></tr>
<tr class="memitem:a7475a8362314f58553b1b8e2abad1dea" id="r_a7475a8362314f58553b1b8e2abad1dea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7475a8362314f58553b1b8e2abad1dea">SHT_ITER_NEXT</a>(iter)</td></tr>
<tr class="memdesc:a7475a8362314f58553b1b8e2abad1dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next entry from an iterator.  <br /></td></tr>
<tr class="memitem:a8fe738f6e2175c8bcc804dfa05279892" id="r_a8fe738f6e2175c8bcc804dfa05279892"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fe738f6e2175c8bcc804dfa05279892">SHT_ITER_REPLACE</a>(iter,  entry)</td></tr>
<tr class="memdesc:a8fe738f6e2175c8bcc804dfa05279892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the last entry returned by an iterator.  <br /></td></tr>
<tr class="memitem:ab33eebaeeeac9f58e2fd7638b1df9e89" id="r_ab33eebaeeeac9f58e2fd7638b1df9e89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab33eebaeeeac9f58e2fd7638b1df9e89">SHT_ITER_ERR</a>(iter)</td></tr>
<tr class="memdesc:ab33eebaeeeac9f58e2fd7638b1df9e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the the error code of an iterator's last error.  <br /></td></tr>
<tr class="memitem:a979b35b0fff0c23091d3a8de47a5dec9" id="r_a979b35b0fff0c23091d3a8de47a5dec9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a979b35b0fff0c23091d3a8de47a5dec9">SHT_ITER_MSG</a>(iter)</td></tr>
<tr class="memdesc:a979b35b0fff0c23091d3a8de47a5dec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a description of an iterator's last error.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5f9d37456d909db3cfeb4496d631bc66" id="r_a5f9d37456d909db3cfeb4496d631bc66"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f9d37456d909db3cfeb4496d631bc66">sht_hashfn_t</a>) (const void *restrict key, void *restrict context)</td></tr>
<tr class="memdesc:a5f9d37456d909db3cfeb4496d631bc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function type.  <br /></td></tr>
<tr class="memitem:a1f5af078e1c27398dcade83ce429047d" id="r_a1f5af078e1c27398dcade83ce429047d"><td class="memItemLeft" align="right" valign="top">typedef _Bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f5af078e1c27398dcade83ce429047d">sht_eqfn_t</a>) (const void *restrict key, const void *restrict entry, void *restrict context)</td></tr>
<tr class="memdesc:a1f5af078e1c27398dcade83ce429047d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison function type.  <br /></td></tr>
<tr class="memitem:a1de927ba1f32597cf294e4efc8c37a6a" id="r_a1de927ba1f32597cf294e4efc8c37a6a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1de927ba1f32597cf294e4efc8c37a6a">sht_freefn_t</a>) (const void *restrict entry, void *restrict context)</td></tr>
<tr class="memdesc:a1de927ba1f32597cf294e4efc8c37a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free function type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a13c6debd7b2ee2b587a74957662713a7" id="r_a13c6debd7b2ee2b587a74957662713a7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> : uint8_t </td></tr>
<tr class="memdesc:a13c6debd7b2ee2b587a74957662713a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes.  <a href="#a13c6debd7b2ee2b587a74957662713a7">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa48d9d4ace5ca91c464f5e9157040e86" id="r_aa48d9d4ace5ca91c464f5e9157040e86"><td class="memItemLeft" align="right" valign="top">struct sht_ht *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa48d9d4ace5ca91c464f5e9157040e86">sht_new_</a> (<a class="el" href="#a5f9d37456d909db3cfeb4496d631bc66">sht_hashfn_t</a> hashfn, <a class="el" href="#a1f5af078e1c27398dcade83ce429047d">sht_eqfn_t</a> eqfn, size_t esize, size_t ealign, enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> *err)</td></tr>
<tr class="memdesc:aa48d9d4ace5ca91c464f5e9157040e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Create a new hash table.)  <br /></td></tr>
<tr class="memitem:a45747c22ee2656dcd16d86ce74ea5ec8" id="r_a45747c22ee2656dcd16d86ce74ea5ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45747c22ee2656dcd16d86ce74ea5ec8">sht_set_hash_ctx</a> (struct sht_ht *ht, void *context)</td></tr>
<tr class="memdesc:a45747c22ee2656dcd16d86ce74ea5ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the "context" for a table's hash function.  <br /></td></tr>
<tr class="memitem:a9d385ed61d95d30e63344ebe6aa522a3" id="r_a9d385ed61d95d30e63344ebe6aa522a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d385ed61d95d30e63344ebe6aa522a3">sht_set_eq_ctx</a> (struct sht_ht *ht, void *context)</td></tr>
<tr class="memdesc:a9d385ed61d95d30e63344ebe6aa522a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the "context" for a table's equality function.  <br /></td></tr>
<tr class="memitem:ab6ac49df5028772a25b41c2c509ecced" id="r_ab6ac49df5028772a25b41c2c509ecced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6ac49df5028772a25b41c2c509ecced">sht_set_freefn</a> (struct sht_ht *ht, <a class="el" href="#a1de927ba1f32597cf294e4efc8c37a6a">sht_freefn_t</a> freefn, void *context)</td></tr>
<tr class="memdesc:ab6ac49df5028772a25b41c2c509ecced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the optional entry resource free function for a table.  <br /></td></tr>
<tr class="memitem:a99d607b370024be6526a17863ee62145" id="r_a99d607b370024be6526a17863ee62145"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99d607b370024be6526a17863ee62145">sht_set_lft</a> (struct sht_ht *ht, uint8_t lft)</td></tr>
<tr class="memdesc:a99d607b370024be6526a17863ee62145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the load factor threshold for a table.  <br /></td></tr>
<tr class="memitem:a85cf673284879f8339015347edde362d" id="r_a85cf673284879f8339015347edde362d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85cf673284879f8339015347edde362d">sht_set_psl_limit</a> (struct sht_ht *ht, uint8_t thold)</td></tr>
<tr class="memdesc:a85cf673284879f8339015347edde362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PSL limit of a table.  <br /></td></tr>
<tr class="memitem:ab6a5c760d62564b28208f9cd780da00f" id="r_ab6a5c760d62564b28208f9cd780da00f"><td class="memItemLeft" align="right" valign="top">_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6a5c760d62564b28208f9cd780da00f">sht_init</a> (struct sht_ht *ht, uint32_t capacity)</td></tr>
<tr class="memdesc:ab6a5c760d62564b28208f9cd780da00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a hash table.  <br /></td></tr>
<tr class="memitem:ae36e072969cef119b1176887dcdc8623" id="r_ae36e072969cef119b1176887dcdc8623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae36e072969cef119b1176887dcdc8623">sht_free</a> (struct sht_ht *ht)</td></tr>
<tr class="memdesc:ae36e072969cef119b1176887dcdc8623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the resources used by a hash table.  <br /></td></tr>
<tr class="memitem:a5cd47d066198640b242e7a1ecebab92e" id="r_a5cd47d066198640b242e7a1ecebab92e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cd47d066198640b242e7a1ecebab92e">sht_add</a> (struct sht_ht *ht, const void *key, const void *entry)</td></tr>
<tr class="memdesc:a5cd47d066198640b242e7a1ecebab92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an entry to the table, if its key is not already present.  <br /></td></tr>
<tr class="memitem:a44c78b1e70265deda028ec34f6c2ecbd" id="r_a44c78b1e70265deda028ec34f6c2ecbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44c78b1e70265deda028ec34f6c2ecbd">sht_set</a> (struct sht_ht *ht, const void *key, const void *entry)</td></tr>
<tr class="memdesc:a44c78b1e70265deda028ec34f6c2ecbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally set the value associated with a key.  <br /></td></tr>
<tr class="memitem:a0dd66cb8cf354a570429662675bc6485" id="r_a0dd66cb8cf354a570429662675bc6485"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dd66cb8cf354a570429662675bc6485">sht_get</a> (struct sht_ht *ht, const void *restrict key)</td></tr>
<tr class="memdesc:a0dd66cb8cf354a570429662675bc6485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup an entry in a table.  <br /></td></tr>
<tr class="memitem:a82e02f941cacb73ed15c616bfe268985" id="r_a82e02f941cacb73ed15c616bfe268985"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82e02f941cacb73ed15c616bfe268985">sht_size</a> (const struct sht_ht *ht)</td></tr>
<tr class="memdesc:a82e02f941cacb73ed15c616bfe268985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of entries in a table.  <br /></td></tr>
<tr class="memitem:a2865bd37b19b90cb3dd3c01aebec7b35" id="r_a2865bd37b19b90cb3dd3c01aebec7b35"><td class="memItemLeft" align="right" valign="top">_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2865bd37b19b90cb3dd3c01aebec7b35">sht_empty</a> (const struct sht_ht *ht)</td></tr>
<tr class="memdesc:a2865bd37b19b90cb3dd3c01aebec7b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a table is empty.  <br /></td></tr>
<tr class="memitem:a773306947d9c00d86a5292def8f0cfa9" id="r_a773306947d9c00d86a5292def8f0cfa9"><td class="memItemLeft" align="right" valign="top">_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a773306947d9c00d86a5292def8f0cfa9">sht_delete</a> (struct sht_ht *ht, const void *restrict key)</td></tr>
<tr class="memdesc:a773306947d9c00d86a5292def8f0cfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an entry from the table.  <br /></td></tr>
<tr class="memitem:a805f5a3b63530022638a169a3cadf9ac" id="r_a805f5a3b63530022638a169a3cadf9ac"><td class="memItemLeft" align="right" valign="top">_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a805f5a3b63530022638a169a3cadf9ac">sht_pop</a> (struct sht_ht *ht, const void *restrict key, void *restrict out)</td></tr>
<tr class="memdesc:a805f5a3b63530022638a169a3cadf9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return an entry from the table.  <br /></td></tr>
<tr class="memitem:a774ddeec974dc6616b06c65e01078a15" id="r_a774ddeec974dc6616b06c65e01078a15"><td class="memItemLeft" align="right" valign="top">_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a774ddeec974dc6616b06c65e01078a15">sht_replace</a> (struct sht_ht *ht, const void *key, const void *entry)</td></tr>
<tr class="memdesc:a774ddeec974dc6616b06c65e01078a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the entry associated with an existing key.  <br /></td></tr>
<tr class="memitem:af2fcd39aa951331b8dc042238c05eee6" id="r_af2fcd39aa951331b8dc042238c05eee6"><td class="memItemLeft" align="right" valign="top">_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2fcd39aa951331b8dc042238c05eee6">sht_swap</a> (struct sht_ht *ht, const void *key, const void *entry, void *out)</td></tr>
<tr class="memdesc:af2fcd39aa951331b8dc042238c05eee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange an existing entry and a new entry.  <br /></td></tr>
<tr class="memitem:a5a76bce06872aedf3253f85a453cf059" id="r_a5a76bce06872aedf3253f85a453cf059"><td class="memItemLeft" align="right" valign="top">struct sht_ro_iter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a76bce06872aedf3253f85a453cf059">sht_ro_iter</a> (struct sht_ht *ht)</td></tr>
<tr class="memdesc:a5a76bce06872aedf3253f85a453cf059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new read-only iterator.  <br /></td></tr>
<tr class="memitem:a1810fbf97bb175be26189efa8023d0b4" id="r_a1810fbf97bb175be26189efa8023d0b4"><td class="memItemLeft" align="right" valign="top">struct sht_rw_iter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1810fbf97bb175be26189efa8023d0b4">sht_rw_iter</a> (struct sht_ht *ht)</td></tr>
<tr class="memdesc:a1810fbf97bb175be26189efa8023d0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new read/write iterator.  <br /></td></tr>
<tr class="memitem:aacf17f485a20817ff310e5519307c9a1" id="r_aacf17f485a20817ff310e5519307c9a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacf17f485a20817ff310e5519307c9a1">sht_ro_iter_free_</a> (struct sht_ro_iter *iter)</td></tr>
<tr class="memdesc:aacf17f485a20817ff310e5519307c9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Free a read-only iterator.)  <br /></td></tr>
<tr class="memitem:a43a4835de587eb7a71970548ff8e4585" id="r_a43a4835de587eb7a71970548ff8e4585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43a4835de587eb7a71970548ff8e4585">sht_rw_iter_free_</a> (struct sht_rw_iter *iter)</td></tr>
<tr class="memdesc:a43a4835de587eb7a71970548ff8e4585"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Free a read/write iterator.)  <br /></td></tr>
<tr class="memitem:a63fee9174bb5ef422d18756f712d7b87" id="r_a63fee9174bb5ef422d18756f712d7b87"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63fee9174bb5ef422d18756f712d7b87">sht_ro_iter_next_</a> (struct sht_ro_iter *iter)</td></tr>
<tr class="memdesc:a63fee9174bb5ef422d18756f712d7b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Get the next entry from a read-only iterator.)  <br /></td></tr>
<tr class="memitem:a07cc2b8eb184f99bcc4fa5cabaaa9f36" id="r_a07cc2b8eb184f99bcc4fa5cabaaa9f36"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07cc2b8eb184f99bcc4fa5cabaaa9f36">sht_rw_iter_next_</a> (struct sht_rw_iter *iter)</td></tr>
<tr class="memdesc:a07cc2b8eb184f99bcc4fa5cabaaa9f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Get the next entry from a read/write iterator.)  <br /></td></tr>
<tr class="memitem:a92921f9869d9305278c7f2d352bf0b70" id="r_a92921f9869d9305278c7f2d352bf0b70"><td class="memItemLeft" align="right" valign="top">_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92921f9869d9305278c7f2d352bf0b70">sht_iter_delete</a> (struct sht_rw_iter *iter)</td></tr>
<tr class="memdesc:a92921f9869d9305278c7f2d352bf0b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last entry returned by a read/write iterator.  <br /></td></tr>
<tr class="memitem:a72a691fe8646d9bd2f2bdce4c637ce15" id="r_a72a691fe8646d9bd2f2bdce4c637ce15"><td class="memItemLeft" align="right" valign="top">_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72a691fe8646d9bd2f2bdce4c637ce15">sht_ro_iter_replace_</a> (struct sht_ro_iter *iter, const void *restrict entry)</td></tr>
<tr class="memdesc:a72a691fe8646d9bd2f2bdce4c637ce15"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Replace the last entry returned by a read-only iterator.)  <br /></td></tr>
<tr class="memitem:ac5a02a924ee7341aa8c963114930c791" id="r_ac5a02a924ee7341aa8c963114930c791"><td class="memItemLeft" align="right" valign="top">_Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5a02a924ee7341aa8c963114930c791">sht_rw_iter_replace_</a> (struct sht_rw_iter *iter, const void *restrict entry)</td></tr>
<tr class="memdesc:ac5a02a924ee7341aa8c963114930c791"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Replace the last entry returned by a read/write iterator.)  <br /></td></tr>
<tr class="memitem:a8a0fc3959fa6efaa802eeb84eab95c44" id="r_a8a0fc3959fa6efaa802eeb84eab95c44"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a0fc3959fa6efaa802eeb84eab95c44">sht_get_err</a> (const struct sht_ht *ht)</td></tr>
<tr class="memdesc:a8a0fc3959fa6efaa802eeb84eab95c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error code of a table's last error.  <br /></td></tr>
<tr class="memitem:a8eae4cade96128f6bfc8fdfc20feb1c9" id="r_a8eae4cade96128f6bfc8fdfc20feb1c9"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8eae4cade96128f6bfc8fdfc20feb1c9">sht_ro_iter_err_</a> (const struct sht_ro_iter *iter)</td></tr>
<tr class="memdesc:a8eae4cade96128f6bfc8fdfc20feb1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Get the error code of a read-only iterator's last error.)  <br /></td></tr>
<tr class="memitem:a9784abbc72986ebb457ebc3d8fafc34b" id="r_a9784abbc72986ebb457ebc3d8fafc34b"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9784abbc72986ebb457ebc3d8fafc34b">sht_rw_iter_err_</a> (const struct sht_rw_iter *iter)</td></tr>
<tr class="memdesc:a9784abbc72986ebb457ebc3d8fafc34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Get the error code of a read/write iterator's last error.)  <br /></td></tr>
<tr class="memitem:aa2bb68233ce1db0c4f1ba50fec4daa84" id="r_aa2bb68233ce1db0c4f1ba50fec4daa84"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2bb68233ce1db0c4f1ba50fec4daa84">sht_msg</a> (enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> err)</td></tr>
<tr class="memdesc:aa2bb68233ce1db0c4f1ba50fec4daa84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description for an error code.  <br /></td></tr>
<tr class="memitem:aae2db74c56749b52273a6e6212d63a0c" id="r_aae2db74c56749b52273a6e6212d63a0c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae2db74c56749b52273a6e6212d63a0c">sht_get_msg</a> (const struct sht_ht *ht)</td></tr>
<tr class="memdesc:aae2db74c56749b52273a6e6212d63a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a description of a table's last error.  <br /></td></tr>
<tr class="memitem:af7d396fce715de8f325d10fa92cad91c" id="r_af7d396fce715de8f325d10fa92cad91c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7d396fce715de8f325d10fa92cad91c">sht_ro_iter_msg_</a> (const struct sht_ro_iter *iter)</td></tr>
<tr class="memdesc:af7d396fce715de8f325d10fa92cad91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Get a description of a read-only iterator's last error.)  <br /></td></tr>
<tr class="memitem:a698cf6920155bca03dc60cd1ea7acffe" id="r_a698cf6920155bca03dc60cd1ea7acffe"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a698cf6920155bca03dc60cd1ea7acffe">sht_rw_iter_msg_</a> (const struct sht_rw_iter *iter)</td></tr>
<tr class="memdesc:a698cf6920155bca03dc60cd1ea7acffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Get a description of a read/write iterator's last error.)  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a59b404e9407b038decbda688475baeb3" id="r_a59b404e9407b038decbda688475baeb3"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59b404e9407b038decbda688475baeb3">sht_abort_print</a> )(const char *msg)</td></tr>
<tr class="memdesc:a59b404e9407b038decbda688475baeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Critical error printing function.  <br /></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad8ef9ee0703cc0982a080f184ecf5255" name="ad8ef9ee0703cc0982a080f184ecf5255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ef9ee0703cc0982a080f184ecf5255">&#9670;&#160;</a></span>SHT_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHT_NEW</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>hashfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>eqfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>etype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new hash table. </p>
<p>This macro is a wrapper for <a class="el" href="#aa48d9d4ace5ca91c464f5e9157040e86" title="(Create a new hash table.)">sht_new_()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>entry {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>      *name;</div>
<div class="line">    <span class="keyword">struct </span>in_addr  address;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>sht_ht *ht;</div>
<div class="line"><span class="keyword">enum</span> <a class="code hl_enumeration" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> err;</div>
<div class="line"> </div>
<div class="line">ht = sht_new(hashfn, eqfn, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry),</div>
<div class="line">             _Alignof(<span class="keyword">struct</span> entry), &amp;err);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Rewrite as ...</span></div>
<div class="line">ht = <a class="code hl_define" href="#ad8ef9ee0703cc0982a080f184ecf5255">SHT_NEW</a>(hashfn, eqfn, <span class="keyword">struct</span> entry, &amp;err);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Without error reporting ...</span></div>
<div class="line">ht = sht_new(hashfn, eqfn, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> entry),</div>
<div class="line">             _Alignof(<span class="keyword">struct</span> entry), NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Becomes ...</span></div>
<div class="line">ht = <a class="code hl_define" href="#ad8ef9ee0703cc0982a080f184ecf5255">SHT_NEW</a>(hashfn, eqfn, <span class="keyword">struct</span> entry);</div>
<div class="ttc" id="asht_8h_html_a13c6debd7b2ee2b587a74957662713a7"><div class="ttname"><a href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a></div><div class="ttdeci">sht_err</div><div class="ttdoc">Error codes.</div><div class="ttdef"><b>Definition</b> <a href="sht_8h_source.html#l00199">sht.h:199</a></div></div>
<div class="ttc" id="asht_8h_html_ad8ef9ee0703cc0982a080f184ecf5255"><div class="ttname"><a href="#ad8ef9ee0703cc0982a080f184ecf5255">SHT_NEW</a></div><div class="ttdeci">#define SHT_NEW(hashfn, eqfn, etype,...)</div><div class="ttdoc">Create a new hash table.</div><div class="ttdef"><b>Definition</b> <a href="sht_8h_source.html#l00455">sht.h:455</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">hashfn</td><td>The function that will be used to compute the hash values of keys. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eqfn</td><td>The function that will be used to compare keys for equality. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">etype</td><td>The type of the entries to be stored in the table. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">...</td><td>Optional output pointer for error reporting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new hash table is returned. On error, <span class="tt">NULL</span> is returned, and an error code is returned in <code class="param">err</code> (if it is not <span class="tt">NULL</span>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa48d9d4ace5ca91c464f5e9157040e86" title="(Create a new hash table.)">sht_new_()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8h_source.html#l00455">455</a> of file <a class="el" href="sht_8h_source.html">sht.h</a>.</p>

</div>
</div>
<a id="a5151d8f5358c4e8794d00175adafdf50" name="a5151d8f5358c4e8794d00175adafdf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5151d8f5358c4e8794d00175adafdf50">&#9670;&#160;</a></span>SHT_ITER_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHT_ITER_FREE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a hash table iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aacf17f485a20817ff310e5519307c9a1" title="(Free a read-only iterator.)">sht_ro_iter_free_()</a> </dd>
<dd>
<a class="el" href="#a43a4835de587eb7a71970548ff8e4585" title="(Free a read/write iterator.)">sht_rw_iter_free_()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8h_source.html#l00497">497</a> of file <a class="el" href="sht_8h_source.html">sht.h</a>.</p>

</div>
</div>
<a id="a7475a8362314f58553b1b8e2abad1dea" name="a7475a8362314f58553b1b8e2abad1dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7475a8362314f58553b1b8e2abad1dea">&#9670;&#160;</a></span>SHT_ITER_NEXT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHT_ITER_NEXT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next entry from an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next entry, if any. If no more entries are available, <span class="tt">NULL</span> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a63fee9174bb5ef422d18756f712d7b87" title="(Get the next entry from a read-only iterator.)">sht_ro_iter_next_()</a> </dd>
<dd>
<a class="el" href="#a07cc2b8eb184f99bcc4fa5cabaaa9f36" title="(Get the next entry from a read/write iterator.)">sht_rw_iter_next_()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8h_source.html#l00510">510</a> of file <a class="el" href="sht_8h_source.html">sht.h</a>.</p>

</div>
</div>
<a id="a8fe738f6e2175c8bcc804dfa05279892" name="a8fe738f6e2175c8bcc804dfa05279892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe738f6e2175c8bcc804dfa05279892">&#9670;&#160;</a></span>SHT_ITER_REPLACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHT_ITER_REPLACE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the last entry returned by an iterator. </p>
<blockquote class="doxtable">
<p><b>WARNING</b></p>
<p>The new entry <b>must</b> have the same key as the entry being replaced. Replacing an entry with an entry that contains a different key will corrupt the table. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true (<span class="tt">1</span>) is returned. On error, false (<span class="tt">0</span>) is returned and the error status of the iterator is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a72a691fe8646d9bd2f2bdce4c637ce15" title="(Replace the last entry returned by a read-only iterator.)">sht_ro_iter_replace_()</a> </dd>
<dd>
<a class="el" href="#ac5a02a924ee7341aa8c963114930c791" title="(Replace the last entry returned by a read/write iterator.)">sht_rw_iter_replace_()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8h_source.html#l00531">531</a> of file <a class="el" href="sht_8h_source.html">sht.h</a>.</p>

</div>
</div>
<a id="ab33eebaeeeac9f58e2fd7638b1df9e89" name="ab33eebaeeeac9f58e2fd7638b1df9e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33eebaeeeac9f58e2fd7638b1df9e89">&#9670;&#160;</a></span>SHT_ITER_ERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHT_ITER_ERR</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the the error code of an iterator's last error. </p>
<p>The value returned by this macro is only valid after a previous iterator function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code that describes the error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>sht_ro_iter_status_() </dd>
<dd>
sht_rw_iter_status_() </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8h_source.html#l00546">546</a> of file <a class="el" href="sht_8h_source.html">sht.h</a>.</p>

</div>
</div>
<a id="a979b35b0fff0c23091d3a8de47a5dec9" name="a979b35b0fff0c23091d3a8de47a5dec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979b35b0fff0c23091d3a8de47a5dec9">&#9670;&#160;</a></span>SHT_ITER_MSG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHT_ITER_MSG</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a description of an iterator's last error. </p>
<p>The value returned by this macro is only valid after a previous iterator function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that describes the error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af7d396fce715de8f325d10fa92cad91c" title="(Get a description of a read-only iterator&#39;s last error.)">sht_ro_iter_msg_()</a> </dd>
<dd>
<a class="el" href="#a698cf6920155bca03dc60cd1ea7acffe" title="(Get a description of a read/write iterator&#39;s last error.)">sht_rw_iter_msg_()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8h_source.html#l00561">561</a> of file <a class="el" href="sht_8h_source.html">sht.h</a>.</p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a5f9d37456d909db3cfeb4496d631bc66" name="a5f9d37456d909db3cfeb4496d631bc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9d37456d909db3cfeb4496d631bc66">&#9670;&#160;</a></span>sht_hashfn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(* sht_hashfn_t) (const void *restrict key, void *restrict context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash function type. </p>
<p>Callback function type used to calculate hash values for keys.</p>
<p>32-bit example, using <a href="https://xxhash.com/doc/v0.8.3/group___x_x_h32__family.html"><span class="tt">XXH32()</span></a>, which requires a seed:</p>
<div class="fragment"><div class="line">uint32_t myhash32(<span class="keyword">const</span> <span class="keywordtype">void</span> *restrict key, <span class="keywordtype">void</span> *restrict context)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">struct </span>mykey *k = key;</div>
<div class="line">    <span class="keyword">const</span> XXH32_hash_t *seed = ctx;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> XXH32(k, <span class="keyword">sizeof</span> *k, *seed);</div>
<div class="line">}</div>
</div><!-- fragment --><p>64-bit example, using <a href="https://xxhash.com/doc/v0.8.3/group___x_x_h3__family.html"><span class="tt">XXH3_64bits()</span></a>, which does not require a seed:</p>
<div class="fragment"><div class="line">uint32_t myhash64(<span class="keyword">const</span> <span class="keywordtype">void</span> *restrict key, <span class="keyword">const</span> <span class="keywordtype">void</span> *restrict)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">struct </span>mykey *k = key;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Throw away the upper 32 bits</span></div>
<div class="line">    <span class="keywordflow">return</span> (uint32_t)XXH3_64bits(k, <span class="keyword">sizeof</span> *k);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to be hashed. </td></tr>
    <tr><td class="paramname">context</td><td>Optional function-specific context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash value of the key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8h_source.html#l00110">110</a> of file <a class="el" href="sht_8h_source.html">sht.h</a>.</p>

</div>
</div>
<a id="a1f5af078e1c27398dcade83ce429047d" name="a1f5af078e1c27398dcade83ce429047d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5af078e1c27398dcade83ce429047d">&#9670;&#160;</a></span>sht_eqfn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef _Bool(* sht_eqfn_t) (const void *restrict key, const void *restrict entry, void *restrict context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison function type. </p>
<p>Callback function type used to compare a key with the key of an existing bucket. This function is only called when the lower 24 bits of the hash values of the two keys are equal.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_entry {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>      *name;</div>
<div class="line">    <span class="keyword">struct </span>in_addr  address;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">_Bool my_cmp(<span class="keyword">const</span> <span class="keywordtype">void</span> *restrict key, <span class="keyword">const</span> <span class="keywordtype">void</span> *restrict entry,</div>
<div class="line">             <span class="keywordtype">void</span> *restrict)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> name = key;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">struct </span>my_entry *<span class="keyword">const</span> e = entry;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> strcmp(name, e-&gt;name) == 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to be compared against the key in the bucket. </td></tr>
    <tr><td class="paramname">entry</td><td>The entry whose key is to be compared. </td></tr>
    <tr><td class="paramname">context</td><td>Optional function-specific context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value that indicates whether <code class="param">key</code> is equal to the key in <code class="param">entry</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8h_source.html#l00144">144</a> of file <a class="el" href="sht_8h_source.html">sht.h</a>.</p>

</div>
</div>
<a id="a1de927ba1f32597cf294e4efc8c37a6a" name="a1de927ba1f32597cf294e4efc8c37a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de927ba1f32597cf294e4efc8c37a6a">&#9670;&#160;</a></span>sht_freefn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sht_freefn_t) (const void *restrict entry, void *restrict context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free function type. </p>
<p>Callback function type used to free entry resources. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_entry {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>      *name;</div>
<div class="line">    <span class="keyword">struct </span>in_addr  address;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_free(<span class="keyword">const</span> <span class="keywordtype">void</span> *restrict entry, <span class="keywordtype">void</span> *restrict)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">struct </span>my_entry *<span class="keyword">const</span> e = entry;</div>
<div class="line">    free(e-&gt;name);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry whose resources should be freed. </td></tr>
    <tr><td class="paramname">context</td><td>Optional function-specific context. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sht_8h_source.html#l00169">169</a> of file <a class="el" href="sht_8h_source.html">sht.h</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a13c6debd7b2ee2b587a74957662713a7" name="a13c6debd7b2ee2b587a74957662713a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c6debd7b2ee2b587a74957662713a7">&#9670;&#160;</a></span>sht_err</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a13c6debd7b2ee2b587a74957662713a7ad8765bcf61a55d7503d226d75586d26e" name="a13c6debd7b2ee2b587a74957662713a7ad8765bcf61a55d7503d226d75586d26e"></a>SHT_ERR_OK&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a13c6debd7b2ee2b587a74957662713a7a87b4856b631b1a7b906e9d6083dbd2a1" name="a13c6debd7b2ee2b587a74957662713a7a87b4856b631b1a7b906e9d6083dbd2a1"></a>SHT_ERR_ALLOC&#160;</td><td class="fielddoc"><p>Memory allocation failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a13c6debd7b2ee2b587a74957662713a7a53990568ace3dc2c06336b660e2ed76a" name="a13c6debd7b2ee2b587a74957662713a7a53990568ace3dc2c06336b660e2ed76a"></a>SHT_ERR_BAD_ESIZE&#160;</td><td class="fielddoc"><p>Entry size too large (&gt; 16KiB). </p>
</td></tr>
<tr><td class="fieldname"><a id="a13c6debd7b2ee2b587a74957662713a7a37247eba50bd8bcf928a3c658a70b858" name="a13c6debd7b2ee2b587a74957662713a7a37247eba50bd8bcf928a3c658a70b858"></a>SHT_ERR_TOOBIG&#160;</td><td class="fielddoc"><p>Requested table size too large. </p>
</td></tr>
<tr><td class="fieldname"><a id="a13c6debd7b2ee2b587a74957662713a7ab78a1ae652df8f6f7238d794c8d0ab51" name="a13c6debd7b2ee2b587a74957662713a7ab78a1ae652df8f6f7238d794c8d0ab51"></a>SHT_ERR_BAD_HASH&#160;</td><td class="fielddoc"><p>Too many hash collisions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a13c6debd7b2ee2b587a74957662713a7ad64bd244886d31dd83f3d2900b3c082f" name="a13c6debd7b2ee2b587a74957662713a7ad64bd244886d31dd83f3d2900b3c082f"></a>SHT_ERR_ITER_LOCK&#160;</td><td class="fielddoc"><p>Can't acquire iterator lock. </p>
</td></tr>
<tr><td class="fieldname"><a id="a13c6debd7b2ee2b587a74957662713a7a517a0ad602a27a475cc5cebc8f483a2a" name="a13c6debd7b2ee2b587a74957662713a7a517a0ad602a27a475cc5cebc8f483a2a"></a>SHT_ERR_ITER_COUNT&#160;</td><td class="fielddoc"><p>Table has too many iterators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a13c6debd7b2ee2b587a74957662713a7abda0c65003c89740342a338a36b07663" name="a13c6debd7b2ee2b587a74957662713a7abda0c65003c89740342a338a36b07663"></a>SHT_ERR_ITER_NO_LAST&#160;</td><td class="fielddoc"><p>Iterator at beginning or end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a13c6debd7b2ee2b587a74957662713a7abfccbb157362313d1766e483c6d3d3a7" name="a13c6debd7b2ee2b587a74957662713a7abfccbb157362313d1766e483c6d3d3a7"></a>SHT_ERR_COUNT&#160;</td><td class="fielddoc"><p>(Not an error; used for bounds checks.) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sht_8h_source.html#l00199">199</a> of file <a class="el" href="sht_8h_source.html">sht.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="aa48d9d4ace5ca91c464f5e9157040e86" name="aa48d9d4ace5ca91c464f5e9157040e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48d9d4ace5ca91c464f5e9157040e86">&#9670;&#160;</a></span>sht_new_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sht_ht * sht_new_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5f9d37456d909db3cfeb4496d631bc66">sht_hashfn_t</a></td>          <td class="paramname"><span class="paramname"><em>hashfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1f5af078e1c27398dcade83ce429047d">sht_eqfn_t</a></td>          <td class="paramname"><span class="paramname"><em>eqfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>esize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>ealign</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> *</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Create a new hash table.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#ad8ef9ee0703cc0982a080f184ecf5255" title="Create a new hash table.">SHT_NEW()</a>. </p>
</blockquote>
<p>A table returned by this function cannot be used until it has been initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">hashfn</td><td>The function that will be used to compute the hash values of keys. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eqfn</td><td>The function that will be used to compare keys for equality. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">esize</td><td>The size of the entries to be stored in the table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ealign</td><td>The alignment of the entries to be stored in the table. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Optional output pointer for error reporting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new hash table is returned. On error, <span class="tt">NULL</span> is returned, and an error code is returned in <code class="param">err</code> (if it is not <span class="tt">NULL</span>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad8ef9ee0703cc0982a080f184ecf5255" title="Create a new hash table.">SHT_NEW()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00298">298</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a45747c22ee2656dcd16d86ce74ea5ec8" name="a45747c22ee2656dcd16d86ce74ea5ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45747c22ee2656dcd16d86ce74ea5ec8">&#9670;&#160;</a></span>sht_set_hash_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_set_hash_ctx </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the "context" for a table's hash function. </p>
<p>Sets the value of the <code class="param">context</code> argument for all calls to the table's hash function.</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called after the table has been initialized. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">context</td><td>The function-specific context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5f9d37456d909db3cfeb4496d631bc66" title="Hash function type.">sht_hashfn_t</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00350">350</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a9d385ed61d95d30e63344ebe6aa522a3" name="a9d385ed61d95d30e63344ebe6aa522a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d385ed61d95d30e63344ebe6aa522a3">&#9670;&#160;</a></span>sht_set_eq_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_set_eq_ctx </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the "context" for a table's equality function. </p>
<p>Sets the value of the <code class="param">context</code> argument for all calls to the table's equality function.</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called after the table has been initialized. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">context</td><td>The function-specific context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1f5af078e1c27398dcade83ce429047d" title="Equality comparison function type.">sht_eqfn_t</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00374">374</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="ab6ac49df5028772a25b41c2c509ecced" name="ab6ac49df5028772a25b41c2c509ecced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ac49df5028772a25b41c2c509ecced">&#9670;&#160;</a></span>sht_set_freefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_set_freefn </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1de927ba1f32597cf294e4efc8c37a6a">sht_freefn_t</a></td>          <td class="paramname"><span class="paramname"><em>freefn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the optional entry resource free function for a table. </p>
<p>An entry free function is used to automatically free resources associated with table entries. It is not required in order to free the entries themselves.</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called after the table has been initialized. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">freefn</td><td>The function to be used to free entry resources. </td></tr>
    <tr><td class="paramname">context</td><td>Optional function-specific context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1de927ba1f32597cf294e4efc8c37a6a" title="Free function type.">sht_freefn_t</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00400">400</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a99d607b370024be6526a17863ee62145" name="a99d607b370024be6526a17863ee62145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d607b370024be6526a17863ee62145">&#9670;&#160;</a></span>sht_set_lft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_set_lft </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>lft</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the load factor threshold for a table. </p>
<p>The load factor threshold (LFT) determines when a table is expanded, in order to accomodate additional entries. The size of the table is doubled when the number of entries it contains exceeds a certain percentage of its size. That percentage is determined by the LFT. Thus, the LFT must be between 1 and 100, although values much different from the default (85) are unlikely to be very useful.</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called after the table has been initialized, nor can it be called with an invalid <code class="param">lft</code> value. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">lft</td><td>The load factor threshold (<span class="tt">1</span> - <span class="tt">100</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00429">429</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a85cf673284879f8339015347edde362d" name="a85cf673284879f8339015347edde362d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85cf673284879f8339015347edde362d">&#9670;&#160;</a></span>sht_set_psl_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_set_psl_limit </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>limit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the PSL limit of a table. </p>
<p>If an entry in the table has a PSL equal to the table's PSL limit, no further entries will be allowed until 1 or more entries that hash to the same "ideal" position are removed. (See <a class="el" href="index.html#limits-and-assumptions">Limits and assumptions</a>.)</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called after the table has been initialized, nor can it be called with an invalid <code class="param">limit</code> value. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">limit</td><td>The PSL limit (<span class="tt">1</span> - <span class="tt">127</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#limits-and-assumptions">Limits and assumptions</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00459">459</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="ab6a5c760d62564b28208f9cd780da00f" name="ab6a5c760d62564b28208f9cd780da00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a5c760d62564b28208f9cd780da00f">&#9670;&#160;</a></span>sht_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Bool sht_init </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a hash table. </p>
<p><code class="param">capacity</code>, along with the table's load factor threshold, is used to calculate the minimum initial size of the table. Setting an appropriate initial size will avoid the need to resize the table as it grows (but will consume unnecessary memory if fewer keys are stored in the table than expected).</p>
<p>If <code class="param">capacity</code> is <span class="tt">0</span>, a default initial capacity (currently <span class="tt">6</span>) is used.</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>If this function succeeds, it must not be called again on the same table. A failed call may be retried, possibly with a lower <code class="param">capacity</code>. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table to be initialized. </td></tr>
    <tr><td class="paramname">capacity</td><td>The initial capacity of the hash table (or <span class="tt">0</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true (<span class="tt">1</span>) is returned. On failure, false (<span class="tt">0</span>) is returned, and the table's error status is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00558">558</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="ae36e072969cef119b1176887dcdc8623" name="ae36e072969cef119b1176887dcdc8623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36e072969cef119b1176887dcdc8623">&#9670;&#160;</a></span>sht_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_free </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the resources used by a hash table. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on a table that has one or more iterators. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01351">1351</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a5cd47d066198640b242e7a1ecebab92e" name="a5cd47d066198640b242e7a1ecebab92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd47d066198640b242e7a1ecebab92e">&#9670;&#160;</a></span>sht_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sht_add </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an entry to the table, if its key is not already present. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table or a table that has one or more iterators. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the new entry. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an error occurs, <span class="tt">-1</span> is returned, the error status of the table is set, and the state of the table is otherwise unchanged. On success, <span class="tt">0</span> is returned if the key was not already present in the table, and the new entry has been added; <span class="tt">1</span> indicates that the key was already present in the table, and the state of the table is unchanged.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sht_8c.html#a44c78b1e70265deda028ec34f6c2ecbd" title="Unconditionally set the value associated with a key.">sht_set()</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00928">928</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a44c78b1e70265deda028ec34f6c2ecbd" name="a44c78b1e70265deda028ec34f6c2ecbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c78b1e70265deda028ec34f6c2ecbd">&#9670;&#160;</a></span>sht_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sht_set </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally set the value associated with a key. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table or a table that has one or more iterators. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the new entry. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an error occurs, <span class="tt">-1</span> is returned, the error status of the table is set, and the state of the table is otherwise unchanged. On success, <span class="tt">0</span> is returned if the key was not already present in the table, and the new entry has been added; <span class="tt">1</span> indicates that the key was already present in the table, and the new entry has replaced it.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sht_8c.html#a5cd47d066198640b242e7a1ecebab92e" title="Add an entry to the table, if its key is not already present.">sht_add()</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00956">956</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a0dd66cb8cf354a570429662675bc6485" name="a0dd66cb8cf354a570429662675bc6485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd66cb8cf354a570429662675bc6485">&#9670;&#160;</a></span>sht_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * sht_get </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup an entry in a table. </p>
<blockquote class="doxtable">
<p><b>WARNING</b></p>
<p>The pointer returned by this function is only valid until the next time the table is changed. Structural changes to the table (adding or removing keys) can cause other entries to be moved within the table, making pointers to those entries invalid. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key for which the entry is to be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the the key is present in the table, a pointer to the key's entry is returned. Otherwise, <span class="tt">NULL</span> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00984">984</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a82e02f941cacb73ed15c616bfe268985" name="a82e02f941cacb73ed15c616bfe268985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e02f941cacb73ed15c616bfe268985">&#9670;&#160;</a></span>sht_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sht_size </td>
          <td>(</td>
          <td class="paramtype">const struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of entries in a table. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entries in the table.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00601">601</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a2865bd37b19b90cb3dd3c01aebec7b35" name="a2865bd37b19b90cb3dd3c01aebec7b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2865bd37b19b90cb3dd3c01aebec7b35">&#9670;&#160;</a></span>sht_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Bool sht_empty </td>
          <td>(</td>
          <td class="paramtype">const struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a table is empty. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True (<span class="tt">1</span>) if the table is empty; false (<span class="tt">0</span>) if it has at least one entry.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00623">623</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a773306947d9c00d86a5292def8f0cfa9" name="a773306947d9c00d86a5292def8f0cfa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773306947d9c00d86a5292def8f0cfa9">&#9670;&#160;</a></span>sht_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Bool sht_delete </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an entry from the table. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table or a table that has one or more iterators. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key for which the entry is to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the key was present in the table, true (<span class="tt">1</span>) is returned. Otherwise, false (<span class="tt">0</span>) is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sht_8c.html#a805f5a3b63530022638a169a3cadf9ac" title="Remove and return an entry from the table.">sht_pop()</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01334">1334</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a805f5a3b63530022638a169a3cadf9ac" name="a805f5a3b63530022638a169a3cadf9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805f5a3b63530022638a169a3cadf9ac">&#9670;&#160;</a></span>sht_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Bool sht_pop </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove and return an entry from the table. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table or a table that has one or more iterators. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>The key for which the entry is to be "popped." </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Entry output buffer. Must be large enough to hold an entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the key was present in the table, true (<span class="tt">1</span>) is returned, and its entry is stored in <code class="param">out</code>. Otherwise, false (<span class="tt">0</span>) is returned (and the contents of <code class="param">out</code> are unchanged).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sht_8c.html#a773306947d9c00d86a5292def8f0cfa9" title="Remove an entry from the table.">sht_delete()</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01311">1311</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a774ddeec974dc6616b06c65e01078a15" name="a774ddeec974dc6616b06c65e01078a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774ddeec974dc6616b06c65e01078a15">&#9670;&#160;</a></span>sht_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Bool sht_replace </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the entry associated with an existing key. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key for which the value is to be replaced. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the key was present in the table, true (<span class="tt">1</span>) is returned, and the entry associated with the key is replaced with the new entry. Otherwise, false (<span class="tt">0</span>) is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01096">1096</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="af2fcd39aa951331b8dc042238c05eee6" name="af2fcd39aa951331b8dc042238c05eee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fcd39aa951331b8dc042238c05eee6">&#9670;&#160;</a></span>sht_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Bool sht_swap </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange an existing entry and a new entry. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key for which the value is to be replaced. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry for the key. </td></tr>
    <tr><td class="paramname">out</td><td>Output buffer for the previous entry. Must be large enough to hold an entry. (<code class="param">out</code> may point to the same object as <code class="param">entry</code>.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the key was present in the table, true (<span class="tt">1</span>) is returned, the entry associated with the key is replaced with the new entry, and the previous entry is copied to <code class="param">out</code>. Otherwise, false (<span class="tt">0</span>) is returned, and the contents of <code class="param">out</code> are unchanged.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01123">1123</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a5a76bce06872aedf3253f85a453cf059" name="a5a76bce06872aedf3253f85a453cf059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a76bce06872aedf3253f85a453cf059">&#9670;&#160;</a></span>sht_ro_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sht_ro_iter * sht_ro_iter </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new read-only iterator. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new iterator is returned. If an error occurs, <span class="tt">NULL</span> is returned, and the error status of the table is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01448">1448</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a1810fbf97bb175be26189efa8023d0b4" name="a1810fbf97bb175be26189efa8023d0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1810fbf97bb175be26189efa8023d0b4">&#9670;&#160;</a></span>sht_rw_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sht_rw_iter * sht_rw_iter </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new read/write iterator. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new iterator is returned. If an error occurs, <span class="tt">NULL</span> is returned, and the error status of the table is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01469">1469</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="aacf17f485a20817ff310e5519307c9a1" name="aacf17f485a20817ff310e5519307c9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf17f485a20817ff310e5519307c9a1">&#9670;&#160;</a></span>sht_ro_iter_free_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_ro_iter_free_ </td>
          <td>(</td>
          <td class="paramtype">struct sht_ro_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Free a read-only iterator.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#a5151d8f5358c4e8794d00175adafdf50" title="Free a hash table iterator.">SHT_ITER_FREE()</a>. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5151d8f5358c4e8794d00175adafdf50" title="Free a hash table iterator.">SHT_ITER_FREE()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01788">1788</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a43a4835de587eb7a71970548ff8e4585" name="a43a4835de587eb7a71970548ff8e4585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a4835de587eb7a71970548ff8e4585">&#9670;&#160;</a></span>sht_rw_iter_free_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_rw_iter_free_ </td>
          <td>(</td>
          <td class="paramtype">struct sht_rw_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Free a read/write iterator.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#a5151d8f5358c4e8794d00175adafdf50" title="Free a hash table iterator.">SHT_ITER_FREE()</a>. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5151d8f5358c4e8794d00175adafdf50" title="Free a hash table iterator.">SHT_ITER_FREE()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01804">1804</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a63fee9174bb5ef422d18756f712d7b87" name="a63fee9174bb5ef422d18756f712d7b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fee9174bb5ef422d18756f712d7b87">&#9670;&#160;</a></span>sht_ro_iter_next_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * sht_ro_iter_next_ </td>
          <td>(</td>
          <td class="paramtype">struct sht_ro_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Get the next entry from a read-only iterator.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#a7475a8362314f58553b1b8e2abad1dea" title="Get the next entry from an iterator.">SHT_ITER_NEXT()</a>. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next entry, if any. If no more entries are available, <span class="tt">NULL</span> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7475a8362314f58553b1b8e2abad1dea" title="Get the next entry from an iterator.">SHT_ITER_NEXT()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01611">1611</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a07cc2b8eb184f99bcc4fa5cabaaa9f36" name="a07cc2b8eb184f99bcc4fa5cabaaa9f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cc2b8eb184f99bcc4fa5cabaaa9f36">&#9670;&#160;</a></span>sht_rw_iter_next_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sht_rw_iter_next_ </td>
          <td>(</td>
          <td class="paramtype">struct sht_rw_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Get the next entry from a read/write iterator.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#a7475a8362314f58553b1b8e2abad1dea" title="Get the next entry from an iterator.">SHT_ITER_NEXT()</a>. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next entry, if any. If no more entries are available, <span class="tt">NULL</span> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7475a8362314f58553b1b8e2abad1dea" title="Get the next entry from an iterator.">SHT_ITER_NEXT()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01630">1630</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a92921f9869d9305278c7f2d352bf0b70" name="a92921f9869d9305278c7f2d352bf0b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92921f9869d9305278c7f2d352bf0b70">&#9670;&#160;</a></span>sht_iter_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Bool sht_iter_delete </td>
          <td>(</td>
          <td class="paramtype">struct sht_rw_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the last entry returned by a read/write iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true (<span class="tt">1</span>) is returned. On error, false (<span class="tt">0</span>) is returned and the error status of the iterator is set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01643">1643</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a72a691fe8646d9bd2f2bdce4c637ce15" name="a72a691fe8646d9bd2f2bdce4c637ce15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a691fe8646d9bd2f2bdce4c637ce15">&#9670;&#160;</a></span>sht_ro_iter_replace_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Bool sht_ro_iter_replace_ </td>
          <td>(</td>
          <td class="paramtype">struct sht_ro_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Replace the last entry returned by a read-only iterator.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#a8fe738f6e2175c8bcc804dfa05279892" title="Replace the last entry returned by an iterator.">SHT_ITER_REPLACE()</a>. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>WARNING</b></p>
<p>The new entry <b>must</b> have the same key as the entry being replaced. Replacing an entry with an entry that contains a different key will corrupt the table. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true (<span class="tt">1</span>) is returned. On error, false (<span class="tt">0</span>) is returned and the error status of the iterator is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8fe738f6e2175c8bcc804dfa05279892" title="Replace the last entry returned by an iterator.">SHT_ITER_REPLACE()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01717">1717</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="ac5a02a924ee7341aa8c963114930c791" name="ac5a02a924ee7341aa8c963114930c791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a02a924ee7341aa8c963114930c791">&#9670;&#160;</a></span>sht_rw_iter_replace_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Bool sht_rw_iter_replace_ </td>
          <td>(</td>
          <td class="paramtype">struct sht_rw_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Replace the last entry returned by a read/write iterator.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#a8fe738f6e2175c8bcc804dfa05279892" title="Replace the last entry returned by an iterator.">SHT_ITER_REPLACE()</a>. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>WARNING</b></p>
<p>The new entry <b>must</b> have the same key as the entry being replaced. Replacing an entry with an entry that contains a different key will corrupt the table. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true (<span class="tt">1</span>) is returned. On error, false (<span class="tt">0</span>) is returned and the error status of the iterator is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8fe738f6e2175c8bcc804dfa05279892" title="Replace the last entry returned by an iterator.">SHT_ITER_REPLACE()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01744">1744</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a8a0fc3959fa6efaa802eeb84eab95c44" name="a8a0fc3959fa6efaa802eeb84eab95c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0fc3959fa6efaa802eeb84eab95c44">&#9670;&#160;</a></span>sht_get_err()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> sht_get_err </td>
          <td>(</td>
          <td class="paramtype">const struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the error code of a table's last error. </p>
<p>The value returned by this function is only valid after a previous function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code that describes the error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00185">185</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a8eae4cade96128f6bfc8fdfc20feb1c9" name="a8eae4cade96128f6bfc8fdfc20feb1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eae4cade96128f6bfc8fdfc20feb1c9">&#9670;&#160;</a></span>sht_ro_iter_err_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> sht_ro_iter_err_ </td>
          <td>(</td>
          <td class="paramtype">const struct sht_ro_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Get the error code of a read-only iterator's last error.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#ab33eebaeeeac9f58e2fd7638b1df9e89" title="Get the the error code of an iterator&#39;s last error.">SHT_ITER_ERR()</a>. </p>
</blockquote>
<p>The value returned by this function is only valid after a previous iterator function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code that describes the error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SHT_ITER_STATUS() </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01490">1490</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a9784abbc72986ebb457ebc3d8fafc34b" name="a9784abbc72986ebb457ebc3d8fafc34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9784abbc72986ebb457ebc3d8fafc34b">&#9670;&#160;</a></span>sht_rw_iter_err_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> sht_rw_iter_err_ </td>
          <td>(</td>
          <td class="paramtype">const struct sht_rw_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Get the error code of a read/write iterator's last error.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#ab33eebaeeeac9f58e2fd7638b1df9e89" title="Get the the error code of an iterator&#39;s last error.">SHT_ITER_ERR()</a>. </p>
</blockquote>
<p>The value returned by this function is only valid after a previous iterator function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code that describes the error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SHT_ITER_STATUS() </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01511">1511</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="aa2bb68233ce1db0c4f1ba50fec4daa84" name="aa2bb68233ce1db0c4f1ba50fec4daa84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bb68233ce1db0c4f1ba50fec4daa84">&#9670;&#160;</a></span>sht_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * sht_msg </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="#a13c6debd7b2ee2b587a74957662713a7">sht_err</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the description for an error code. </p>
<p><b>NOTE:</b> This function will abort the calling program if an invalid value of <code class="param">err</code> is specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>The error code. Must in the range <span class="tt"><a class="el" href="#a13c6debd7b2ee2b587a74957662713a7ad8765bcf61a55d7503d226d75586d26e" title="No error.">SHT_ERR_OK</a></span> to <span class="tt"><a class="el" href="#a13c6debd7b2ee2b587a74957662713a7abfccbb157362313d1766e483c6d3d3a7" title="(Not an error; used for bounds checks.)">SHT_ERR_COUNT</a> - 1</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string describing the error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00201">201</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="aae2db74c56749b52273a6e6212d63a0c" name="aae2db74c56749b52273a6e6212d63a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2db74c56749b52273a6e6212d63a0c">&#9670;&#160;</a></span>sht_get_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * sht_get_msg </td>
          <td>(</td>
          <td class="paramtype">const struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a description of a table's last error. </p>
<p>The value returned by this function is only valid after a previous function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string describing the error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00234">234</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="af7d396fce715de8f325d10fa92cad91c" name="af7d396fce715de8f325d10fa92cad91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d396fce715de8f325d10fa92cad91c">&#9670;&#160;</a></span>sht_ro_iter_msg_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * sht_ro_iter_msg_ </td>
          <td>(</td>
          <td class="paramtype">const struct sht_ro_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Get a description of a read-only iterator's last error.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#a979b35b0fff0c23091d3a8de47a5dec9" title="Get a description of an iterator&#39;s last error.">SHT_ITER_MSG()</a>. </p>
</blockquote>
<p>The value returned by this function is only valid after a previous iterator function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that describes the error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a979b35b0fff0c23091d3a8de47a5dec9" title="Get a description of an iterator&#39;s last error.">SHT_ITER_MSG()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01532">1532</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a698cf6920155bca03dc60cd1ea7acffe" name="a698cf6920155bca03dc60cd1ea7acffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698cf6920155bca03dc60cd1ea7acffe">&#9670;&#160;</a></span>sht_rw_iter_msg_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * sht_rw_iter_msg_ </td>
          <td>(</td>
          <td class="paramtype">const struct sht_rw_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Get a description of a read/write iterator's last error.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="#a979b35b0fff0c23091d3a8de47a5dec9" title="Get a description of an iterator&#39;s last error.">SHT_ITER_MSG()</a>. </p>
</blockquote>
<p>The value returned by this function is only valid after a previous iterator function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that describes the error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a979b35b0fff0c23091d3a8de47a5dec9" title="Get a description of an iterator&#39;s last error.">SHT_ITER_MSG()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01553">1553</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a59b404e9407b038decbda688475baeb3" name="a59b404e9407b038decbda688475baeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b404e9407b038decbda688475baeb3">&#9670;&#160;</a></span>sht_abort_print</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void(* sht_abort_print) (const char *msg) </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Critical error printing function. </p>
<p>If the calling program violates this library's contract, the library will print an error message and abort the program. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) This variable can be set to customize how the error message is printed or logged.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> log_sht_err(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg)</div>
<div class="line">{</div>
<div class="line">    syslog(LOG_CRIT, <span class="stringliteral">&quot;SHT library error: %s&quot;</span>, msg);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">sht_abort_print = log_sht_err;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The error message (not newline terminated).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00161">161</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>src</b></li><li class="navelem"><a href="sht_8h.html">sht.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
