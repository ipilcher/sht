<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SHT Hash Table: src/sht.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SHT Hash Table
   </div>
   <div id="projectbrief">SHT Hash Table</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('sht_8c.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">sht.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="sht_8h_source.html">sht.h</a>&quot;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div>
<p><a href="sht_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8a0fc3959fa6efaa802eeb84eab95c44" id="r_a8a0fc3959fa6efaa802eeb84eab95c44"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="sht_8h.html#a13c6debd7b2ee2b587a74957662713a7">sht_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a0fc3959fa6efaa802eeb84eab95c44">sht_get_err</a> (const struct sht_ht *ht)</td></tr>
<tr class="memdesc:a8a0fc3959fa6efaa802eeb84eab95c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error code of a table's last error.  <br /></td></tr>
<tr class="memitem:aa2bb68233ce1db0c4f1ba50fec4daa84" id="r_aa2bb68233ce1db0c4f1ba50fec4daa84"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2bb68233ce1db0c4f1ba50fec4daa84">sht_msg</a> (enum <a class="el" href="sht_8h.html#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> err)</td></tr>
<tr class="memdesc:aa2bb68233ce1db0c4f1ba50fec4daa84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description for an error code.  <br /></td></tr>
<tr class="memitem:aae2db74c56749b52273a6e6212d63a0c" id="r_aae2db74c56749b52273a6e6212d63a0c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae2db74c56749b52273a6e6212d63a0c">sht_get_msg</a> (const struct sht_ht *ht)</td></tr>
<tr class="memdesc:aae2db74c56749b52273a6e6212d63a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a description of a table's last error.  <br /></td></tr>
<tr class="memitem:adb0d21d1b389094b3188be811ed5616c" id="r_adb0d21d1b389094b3188be811ed5616c"><td class="memItemLeft" align="right" valign="top">struct sht_ht *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb0d21d1b389094b3188be811ed5616c">sht_new_</a> (<a class="el" href="sht_8h.html#a5f9d37456d909db3cfeb4496d631bc66">sht_hashfn_t</a> hashfn, <a class="el" href="sht_8h.html#ac7dfae93089b6b92a2b83f8e29e0d5d6">sht_eqfn_t</a> eqfn, <a class="el" href="sht_8h.html#a1de927ba1f32597cf294e4efc8c37a6a">sht_freefn_t</a> freefn, size_t esize, size_t ealign, enum <a class="el" href="sht_8h.html#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> *err)</td></tr>
<tr class="memdesc:adb0d21d1b389094b3188be811ed5616c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Create a new hash table.)  <br /></td></tr>
<tr class="memitem:a45747c22ee2656dcd16d86ce74ea5ec8" id="r_a45747c22ee2656dcd16d86ce74ea5ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45747c22ee2656dcd16d86ce74ea5ec8">sht_set_hash_ctx</a> (struct sht_ht *ht, void *context)</td></tr>
<tr class="memdesc:a45747c22ee2656dcd16d86ce74ea5ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the "context" for a table's hash function.  <br /></td></tr>
<tr class="memitem:a9d385ed61d95d30e63344ebe6aa522a3" id="r_a9d385ed61d95d30e63344ebe6aa522a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d385ed61d95d30e63344ebe6aa522a3">sht_set_eq_ctx</a> (struct sht_ht *ht, void *context)</td></tr>
<tr class="memdesc:a9d385ed61d95d30e63344ebe6aa522a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the "context" for a table's equality function.  <br /></td></tr>
<tr class="memitem:aae724bd6d23b2cc6921fe638c75c1b48" id="r_aae724bd6d23b2cc6921fe638c75c1b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae724bd6d23b2cc6921fe638c75c1b48">sht_set_free_ctx</a> (struct sht_ht *ht, void *context)</td></tr>
<tr class="memdesc:aae724bd6d23b2cc6921fe638c75c1b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the "context" for a table's free function.  <br /></td></tr>
<tr class="memitem:a99d607b370024be6526a17863ee62145" id="r_a99d607b370024be6526a17863ee62145"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99d607b370024be6526a17863ee62145">sht_set_lft</a> (struct sht_ht *ht, uint8_t lft)</td></tr>
<tr class="memdesc:a99d607b370024be6526a17863ee62145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the load factor threshold for a table.  <br /></td></tr>
<tr class="memitem:aa0790506e1bb1f4c3018feaa07d9fe62" id="r_aa0790506e1bb1f4c3018feaa07d9fe62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0790506e1bb1f4c3018feaa07d9fe62">sht_set_psl_limit</a> (struct sht_ht *ht, uint8_t limit)</td></tr>
<tr class="memdesc:aa0790506e1bb1f4c3018feaa07d9fe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PSL limit of a table.  <br /></td></tr>
<tr class="memitem:a4eaf764fc86d5f9428d6763f3aecadcd" id="r_a4eaf764fc86d5f9428d6763f3aecadcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eaf764fc86d5f9428d6763f3aecadcd">sht_init</a> (struct sht_ht *ht, uint32_t capacity)</td></tr>
<tr class="memdesc:a4eaf764fc86d5f9428d6763f3aecadcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a hash table.  <br /></td></tr>
<tr class="memitem:a82e02f941cacb73ed15c616bfe268985" id="r_a82e02f941cacb73ed15c616bfe268985"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82e02f941cacb73ed15c616bfe268985">sht_size</a> (const struct sht_ht *ht)</td></tr>
<tr class="memdesc:a82e02f941cacb73ed15c616bfe268985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of entries in a table.  <br /></td></tr>
<tr class="memitem:a6ccef7db69da7e3394c146b0e5e63f42" id="r_a6ccef7db69da7e3394c146b0e5e63f42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ccef7db69da7e3394c146b0e5e63f42">sht_empty</a> (const struct sht_ht *ht)</td></tr>
<tr class="memdesc:a6ccef7db69da7e3394c146b0e5e63f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a table is empty.  <br /></td></tr>
<tr class="memitem:a5cd47d066198640b242e7a1ecebab92e" id="r_a5cd47d066198640b242e7a1ecebab92e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cd47d066198640b242e7a1ecebab92e">sht_add</a> (struct sht_ht *ht, const void *key, const void *entry)</td></tr>
<tr class="memdesc:a5cd47d066198640b242e7a1ecebab92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an entry to the table, if its key is not already present.  <br /></td></tr>
<tr class="memitem:a44c78b1e70265deda028ec34f6c2ecbd" id="r_a44c78b1e70265deda028ec34f6c2ecbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44c78b1e70265deda028ec34f6c2ecbd">sht_set</a> (struct sht_ht *ht, const void *key, const void *entry)</td></tr>
<tr class="memdesc:a44c78b1e70265deda028ec34f6c2ecbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally set the value associated with a key.  <br /></td></tr>
<tr class="memitem:a0dd66cb8cf354a570429662675bc6485" id="r_a0dd66cb8cf354a570429662675bc6485"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dd66cb8cf354a570429662675bc6485">sht_get</a> (struct sht_ht *ht, const void *restrict key)</td></tr>
<tr class="memdesc:a0dd66cb8cf354a570429662675bc6485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup an entry in a table.  <br /></td></tr>
<tr class="memitem:a195b40910c12c6dc21fbfc5b2f4c2716" id="r_a195b40910c12c6dc21fbfc5b2f4c2716"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a195b40910c12c6dc21fbfc5b2f4c2716">sht_replace</a> (struct sht_ht *ht, const void *key, const void *entry)</td></tr>
<tr class="memdesc:a195b40910c12c6dc21fbfc5b2f4c2716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the entry associated with an existing key.  <br /></td></tr>
<tr class="memitem:a6d531c171c19475d113e6631ee23ef06" id="r_a6d531c171c19475d113e6631ee23ef06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d531c171c19475d113e6631ee23ef06">sht_swap</a> (struct sht_ht *ht, const void *key, const void *entry, void *out)</td></tr>
<tr class="memdesc:a6d531c171c19475d113e6631ee23ef06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange an existing entry and a new entry.  <br /></td></tr>
<tr class="memitem:a826a9df51c8fe4ed3df707191ac6a105" id="r_a826a9df51c8fe4ed3df707191ac6a105"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a826a9df51c8fe4ed3df707191ac6a105">sht_pop</a> (struct sht_ht *ht, const void *restrict key, void *restrict out)</td></tr>
<tr class="memdesc:a826a9df51c8fe4ed3df707191ac6a105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return an entry from the table.  <br /></td></tr>
<tr class="memitem:a16a6d148b8a1e9f24eeb56c3db568105" id="r_a16a6d148b8a1e9f24eeb56c3db568105"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16a6d148b8a1e9f24eeb56c3db568105">sht_delete</a> (struct sht_ht *ht, const void *restrict key)</td></tr>
<tr class="memdesc:a16a6d148b8a1e9f24eeb56c3db568105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an entry from the table.  <br /></td></tr>
<tr class="memitem:ae36e072969cef119b1176887dcdc8623" id="r_ae36e072969cef119b1176887dcdc8623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae36e072969cef119b1176887dcdc8623">sht_free</a> (struct sht_ht *ht)</td></tr>
<tr class="memdesc:ae36e072969cef119b1176887dcdc8623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the resources used by a hash table.  <br /></td></tr>
<tr class="memitem:a82f0e05af3fc1174b3ff844ad1511362" id="r_a82f0e05af3fc1174b3ff844ad1511362"><td class="memItemLeft" align="right" valign="top">struct sht_iter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82f0e05af3fc1174b3ff844ad1511362">sht_iter_new</a> (struct sht_ht *ht, enum <a class="el" href="sht_8h.html#a8c782ca0214a2c1d605ac0fa25274e0e">sht_iter_type</a> type)</td></tr>
<tr class="memdesc:a82f0e05af3fc1174b3ff844ad1511362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new iterator.  <br /></td></tr>
<tr class="memitem:ab1a800442ed16198b4317cf78e2e815a" id="r_ab1a800442ed16198b4317cf78e2e815a"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="sht_8h.html#a13c6debd7b2ee2b587a74957662713a7">sht_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1a800442ed16198b4317cf78e2e815a">sht_iter_err</a> (const struct sht_iter *iter)</td></tr>
<tr class="memdesc:ab1a800442ed16198b4317cf78e2e815a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error code of an iterator's last error.  <br /></td></tr>
<tr class="memitem:a21446834bf764bc08865cb2934e0960c" id="r_a21446834bf764bc08865cb2934e0960c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21446834bf764bc08865cb2934e0960c">sht_iter_msg</a> (const struct sht_iter *iter)</td></tr>
<tr class="memdesc:a21446834bf764bc08865cb2934e0960c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a description of an iterator's last error.  <br /></td></tr>
<tr class="memitem:a2e5418f907f471d6b3670add83cfd77b" id="r_a2e5418f907f471d6b3670add83cfd77b"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e5418f907f471d6b3670add83cfd77b">sht_iter_next</a> (struct sht_iter *iter)</td></tr>
<tr class="memdesc:a2e5418f907f471d6b3670add83cfd77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next entry from an iterator.  <br /></td></tr>
<tr class="memitem:a84cfd8fc36e1ba98ab427d82802ad420" id="r_a84cfd8fc36e1ba98ab427d82802ad420"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84cfd8fc36e1ba98ab427d82802ad420">sht_iter_delete</a> (struct sht_iter *iter)</td></tr>
<tr class="memdesc:a84cfd8fc36e1ba98ab427d82802ad420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last entry returned by a <b>read/write</b> iterator.  <br /></td></tr>
<tr class="memitem:a65154d9195575fab4ad984fbbcfaf13d" id="r_a65154d9195575fab4ad984fbbcfaf13d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65154d9195575fab4ad984fbbcfaf13d">sht_iter_replace</a> (struct sht_iter *iter, const void *restrict entry)</td></tr>
<tr class="memdesc:a65154d9195575fab4ad984fbbcfaf13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the last entry returned by an iterator.  <br /></td></tr>
<tr class="memitem:ac3f4b138ac33ecb1bbb59aa4a73354f8" id="r_ac3f4b138ac33ecb1bbb59aa4a73354f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3f4b138ac33ecb1bbb59aa4a73354f8">sht_iter_free</a> (struct sht_iter *iter)</td></tr>
<tr class="memdesc:ac3f4b138ac33ecb1bbb59aa4a73354f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an iterator.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a8a0fc3959fa6efaa802eeb84eab95c44" name="a8a0fc3959fa6efaa802eeb84eab95c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0fc3959fa6efaa802eeb84eab95c44">&#9670;&#160;</a></span>sht_get_err()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sht_8h.html#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> sht_get_err </td>
          <td>(</td>
          <td class="paramtype">const struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the error code of a table's last error. </p>
<p>The value returned by this function is only valid after a previous function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code that describes the error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00165">165</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="aa2bb68233ce1db0c4f1ba50fec4daa84" name="aa2bb68233ce1db0c4f1ba50fec4daa84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bb68233ce1db0c4f1ba50fec4daa84">&#9670;&#160;</a></span>sht_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * sht_msg </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="sht_8h.html#a13c6debd7b2ee2b587a74957662713a7">sht_err</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the description for an error code. </p>
<p><b>NOTE:</b> This function will abort the calling program if an invalid value of <code class="param">err</code> is specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>The error code. Must in the range <span class="tt"><a class="el" href="sht_8h.html#a13c6debd7b2ee2b587a74957662713a7ad8765bcf61a55d7503d226d75586d26e" title="No error.">SHT_ERR_OK</a></span> to <span class="tt"><a class="el" href="sht_8h.html#a13c6debd7b2ee2b587a74957662713a7abfccbb157362313d1766e483c6d3d3a7" title="(Not an error; used for bounds checks.)">SHT_ERR_COUNT</a> - 1</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string describing the error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00181">181</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="aae2db74c56749b52273a6e6212d63a0c" name="aae2db74c56749b52273a6e6212d63a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2db74c56749b52273a6e6212d63a0c">&#9670;&#160;</a></span>sht_get_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * sht_get_msg </td>
          <td>(</td>
          <td class="paramtype">const struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a description of a table's last error. </p>
<p>The value returned by this function is only valid after a previous function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string describing the error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00213">213</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="adb0d21d1b389094b3188be811ed5616c" name="adb0d21d1b389094b3188be811ed5616c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0d21d1b389094b3188be811ed5616c">&#9670;&#160;</a></span>sht_new_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sht_ht * sht_new_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sht_8h.html#a5f9d37456d909db3cfeb4496d631bc66">sht_hashfn_t</a></td>          <td class="paramname"><span class="paramname"><em>hashfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sht_8h.html#ac7dfae93089b6b92a2b83f8e29e0d5d6">sht_eqfn_t</a></td>          <td class="paramname"><span class="paramname"><em>eqfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sht_8h.html#a1de927ba1f32597cf294e4efc8c37a6a">sht_freefn_t</a></td>          <td class="paramname"><span class="paramname"><em>freefn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>esize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>ealign</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="sht_8h.html#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> *</td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Create a new hash table.) </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>Do not call this function directly. Use <a class="el" href="sht_8h.html#aff395306d3299b2e23d1ec5dfb0b70d0" title="Create a new hash table.">SHT_NEW()</a>. </p>
</blockquote>
<p>A table returned by this function cannot be used until it has been initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">hashfn</td><td>Function to be used to compute the hash values of keys. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eqfn</td><td>Function to be used to compare keys for equality. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">freefn</td><td>Function to be used to free entry resources. (May be <span class="tt">NULL</span>.) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">esize</td><td>The size of the entries to be stored in the table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ealign</td><td>The alignment of the entries to be stored in the table. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>Optional output pointer for error reporting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new hash table is returned. On error, <span class="tt">NULL</span> is returned, and an error code is returned in <code class="param">err</code> (if it is not <span class="tt">NULL</span>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sht_8h.html#aff395306d3299b2e23d1ec5dfb0b70d0" title="Create a new hash table.">SHT_NEW()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00277">277</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a45747c22ee2656dcd16d86ce74ea5ec8" name="a45747c22ee2656dcd16d86ce74ea5ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45747c22ee2656dcd16d86ce74ea5ec8">&#9670;&#160;</a></span>sht_set_hash_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_set_hash_ctx </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the "context" for a table's hash function. </p>
<p>Sets the value of the <code class="param">context</code> argument for all calls to the table's hash function.</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called after the table has been initialized. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">context</td><td>The function-specific context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sht_8h.html#a5f9d37456d909db3cfeb4496d631bc66" title="Hash function type.">sht_hashfn_t</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00331">331</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a9d385ed61d95d30e63344ebe6aa522a3" name="a9d385ed61d95d30e63344ebe6aa522a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d385ed61d95d30e63344ebe6aa522a3">&#9670;&#160;</a></span>sht_set_eq_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_set_eq_ctx </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the "context" for a table's equality function. </p>
<p>Sets the value of the <code class="param">context</code> argument for all calls to the table's equality function.</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called after the table has been initialized. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">context</td><td>The function-specific context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sht_8h.html#ac7dfae93089b6b92a2b83f8e29e0d5d6" title="Equality comparison function type.">sht_eqfn_t</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00355">355</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="aae724bd6d23b2cc6921fe638c75c1b48" name="aae724bd6d23b2cc6921fe638c75c1b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae724bd6d23b2cc6921fe638c75c1b48">&#9670;&#160;</a></span>sht_set_free_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_set_free_ctx </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the "context" for a table's free function. </p>
<p>Sets the value of the <code class="param">context</code> argument for all calls to the table's free function.</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called after the table has been initialized. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">context</td><td>Optional function-specific context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sht_8h.html#a1de927ba1f32597cf294e4efc8c37a6a" title="Free function type.">sht_freefn_t</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00379">379</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a99d607b370024be6526a17863ee62145" name="a99d607b370024be6526a17863ee62145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d607b370024be6526a17863ee62145">&#9670;&#160;</a></span>sht_set_lft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_set_lft </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>lft</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the load factor threshold for a table. </p>
<p>The load factor threshold (LFT) determines when a table is expanded, in order to accomodate additional entries. The size of the table is doubled when the number of entries it contains exceeds a certain percentage of its size. That percentage is determined by the LFT. Thus, the LFT must be between 1 and 100, although values much different from the default (85) are unlikely to be very useful.</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called after the table has been initialized, nor can it be called with an invalid <code class="param">lft</code> value. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">lft</td><td>The load factor threshold (<span class="tt">1</span> - <span class="tt">100</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00407">407</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="aa0790506e1bb1f4c3018feaa07d9fe62" name="aa0790506e1bb1f4c3018feaa07d9fe62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0790506e1bb1f4c3018feaa07d9fe62">&#9670;&#160;</a></span>sht_set_psl_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_set_psl_limit </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>limit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the PSL limit of a table. </p>
<p>If an entry in the table has a PSL equal to the table's PSL limit, no further entries will be allowed until 1 or more entries that hash to the same "ideal" position are removed. (See <a class="el" href="index.html#limits-and-assumptions">Limits and assumptions</a>.)</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called after the table has been initialized, nor can it be called with an invalid <code class="param">limit</code> value. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">limit</td><td>The PSL limit (<span class="tt">1</span> - <span class="tt">127</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#limits-and-assumptions">Limits and assumptions</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00437">437</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a4eaf764fc86d5f9428d6763f3aecadcd" name="a4eaf764fc86d5f9428d6763f3aecadcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eaf764fc86d5f9428d6763f3aecadcd">&#9670;&#160;</a></span>sht_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sht_init </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a hash table. </p>
<p><code class="param">capacity</code>, along with the table's load factor threshold, is used to calculate the minimum initial size of the table. Setting an appropriate initial size will avoid the need to resize the table as it grows (but will consume unnecessary memory if fewer keys are stored in the table than expected).</p>
<p>If <code class="param">capacity</code> is <span class="tt">0</span>, a default initial capacity (currently <span class="tt">6</span>) is used.</p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>If this function succeeds, it must not be called again on the same table. A failed call may be retried, possibly with a lower <code class="param">capacity</code>. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table to be initialized. </td></tr>
    <tr><td class="paramname">capacity</td><td>The initial capacity of the hash table (or <span class="tt">0</span>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true (<span class="tt">1</span>) is returned. On failure, false (<span class="tt">0</span>) is returned, and the table's error status is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00536">536</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a82e02f941cacb73ed15c616bfe268985" name="a82e02f941cacb73ed15c616bfe268985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e02f941cacb73ed15c616bfe268985">&#9670;&#160;</a></span>sht_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sht_size </td>
          <td>(</td>
          <td class="paramtype">const struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of entries in a table. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entries in the table.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00579">579</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a6ccef7db69da7e3394c146b0e5e63f42" name="a6ccef7db69da7e3394c146b0e5e63f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccef7db69da7e3394c146b0e5e63f42">&#9670;&#160;</a></span>sht_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sht_empty </td>
          <td>(</td>
          <td class="paramtype">const struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a table is empty. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True (<span class="tt">1</span>) if the table is empty; false (<span class="tt">0</span>) if it has at least one entry.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00601">601</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a5cd47d066198640b242e7a1ecebab92e" name="a5cd47d066198640b242e7a1ecebab92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd47d066198640b242e7a1ecebab92e">&#9670;&#160;</a></span>sht_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sht_add </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an entry to the table, if its key is not already present. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table or a table that has one or more iterators. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the new entry. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an error occurs, <span class="tt">-1</span> is returned, the error status of the table is set, and the state of the table is otherwise unchanged. On success, <span class="tt">0</span> is returned if the key was not already present in the table, and the new entry has been added; <span class="tt">1</span> indicates that the key was already present in the table, and the state of the table is unchanged.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a44c78b1e70265deda028ec34f6c2ecbd" title="Unconditionally set the value associated with a key.">sht_set()</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00906">906</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a44c78b1e70265deda028ec34f6c2ecbd" name="a44c78b1e70265deda028ec34f6c2ecbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c78b1e70265deda028ec34f6c2ecbd">&#9670;&#160;</a></span>sht_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sht_set </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally set the value associated with a key. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table or a table that has one or more iterators. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the new entry. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an error occurs, <span class="tt">-1</span> is returned, the error status of the table is set, and the state of the table is otherwise unchanged. On success, <span class="tt">0</span> is returned if the key was not already present in the table, and the new entry has been added; <span class="tt">1</span> indicates that the key was already present in the table, and the new entry has replaced it.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5cd47d066198640b242e7a1ecebab92e" title="Add an entry to the table, if its key is not already present.">sht_add()</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00934">934</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a0dd66cb8cf354a570429662675bc6485" name="a0dd66cb8cf354a570429662675bc6485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd66cb8cf354a570429662675bc6485">&#9670;&#160;</a></span>sht_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * sht_get </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup an entry in a table. </p>
<blockquote class="doxtable">
<p><b>WARNING</b></p>
<p>The pointer returned by this function is only valid until the next time the table is changed. Structural changes to the table (adding or removing keys) can cause other entries to be moved within the table, making pointers to those entries invalid. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key for which the entry is to be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the the key is present in the table, a pointer to the key's entry is returned. Otherwise, <span class="tt">NULL</span> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l00962">962</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a195b40910c12c6dc21fbfc5b2f4c2716" name="a195b40910c12c6dc21fbfc5b2f4c2716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195b40910c12c6dc21fbfc5b2f4c2716">&#9670;&#160;</a></span>sht_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sht_replace </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the entry associated with an existing key. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key for which the value is to be replaced. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the key was present in the table, true (<span class="tt">1</span>) is returned, and the entry associated with the key is replaced with the new entry. Otherwise, false (<span class="tt">0</span>) is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01074">1074</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a6d531c171c19475d113e6631ee23ef06" name="a6d531c171c19475d113e6631ee23ef06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d531c171c19475d113e6631ee23ef06">&#9670;&#160;</a></span>sht_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sht_swap </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange an existing entry and a new entry. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key for which the value is to be replaced. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry for the key. </td></tr>
    <tr><td class="paramname">out</td><td>Output buffer for the previous entry. Must be large enough to hold an entry. (<code class="param">out</code> may point to the same object as <code class="param">entry</code>.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the key was present in the table, true (<span class="tt">1</span>) is returned, the entry associated with the key is replaced with the new entry, and the previous entry is copied to <code class="param">out</code>. Otherwise, false (<span class="tt">0</span>) is returned, and the contents of <code class="param">out</code> are unchanged.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01101">1101</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a826a9df51c8fe4ed3df707191ac6a105" name="a826a9df51c8fe4ed3df707191ac6a105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826a9df51c8fe4ed3df707191ac6a105">&#9670;&#160;</a></span>sht_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sht_pop </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove and return an entry from the table. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table or a table that has one or more iterators. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>The key for which the entry is to be "popped." </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Entry output buffer. Must be large enough to hold an entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the key was present in the table, true (<span class="tt">1</span>) is returned, and its entry is stored in <code class="param">out</code>. Otherwise, false (<span class="tt">0</span>) is returned (and the contents of <code class="param">out</code> are unchanged).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a16a6d148b8a1e9f24eeb56c3db568105" title="Remove an entry from the table.">sht_delete()</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01289">1289</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a16a6d148b8a1e9f24eeb56c3db568105" name="a16a6d148b8a1e9f24eeb56c3db568105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a6d148b8a1e9f24eeb56c3db568105">&#9670;&#160;</a></span>sht_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sht_delete </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an entry from the table. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on an unitialized table or a table that has one or more iterators. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">key</td><td>The key for which the entry is to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the key was present in the table, true (<span class="tt">1</span>) is returned. Otherwise, false (<span class="tt">0</span>) is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a826a9df51c8fe4ed3df707191ac6a105" title="Remove and return an entry from the table.">sht_pop()</a> </dd>
<dd>
<a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01312">1312</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="ae36e072969cef119b1176887dcdc8623" name="ae36e072969cef119b1176887dcdc8623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36e072969cef119b1176887dcdc8623">&#9670;&#160;</a></span>sht_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_free </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the resources used by a hash table. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on a table that has one or more iterators. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abort-conditions">Abort conditions</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01329">1329</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a82f0e05af3fc1174b3ff844ad1511362" name="a82f0e05af3fc1174b3ff844ad1511362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f0e05af3fc1174b3ff844ad1511362">&#9670;&#160;</a></span>sht_iter_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sht_iter * sht_iter_new </td>
          <td>(</td>
          <td class="paramtype">struct sht_ht *</td>          <td class="paramname"><span class="paramname"><em>ht</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="sht_8h.html#a8c782ca0214a2c1d605ac0fa25274e0e">sht_iter_type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the iterator (read-only or read/write).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the new iterator is returned. If memory allocation fails, <span class="tt">NULL</span> is returned, and the error status of the table is set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01363">1363</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="ab1a800442ed16198b4317cf78e2e815a" name="ab1a800442ed16198b4317cf78e2e815a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a800442ed16198b4317cf78e2e815a">&#9670;&#160;</a></span>sht_iter_err()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sht_8h.html#a13c6debd7b2ee2b587a74957662713a7">sht_err</a> sht_iter_err </td>
          <td>(</td>
          <td class="paramtype">const struct sht_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the error code of an iterator's last error. </p>
<p>The value returned by this function is only valid after a previous iterator function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code that describes the error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01416">1416</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a21446834bf764bc08865cb2934e0960c" name="a21446834bf764bc08865cb2934e0960c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21446834bf764bc08865cb2934e0960c">&#9670;&#160;</a></span>sht_iter_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * sht_iter_msg </td>
          <td>(</td>
          <td class="paramtype">const struct sht_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a description of an iterator's last error. </p>
<p>The value returned by this function is only valid after a previous iterator function call indicated an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that describes the error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01431">1431</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a2e5418f907f471d6b3670add83cfd77b" name="a2e5418f907f471d6b3670add83cfd77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5418f907f471d6b3670add83cfd77b">&#9670;&#160;</a></span>sht_iter_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * sht_iter_next </td>
          <td>(</td>
          <td class="paramtype">struct sht_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next entry from an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next entry, if any. If no more entries are available, <span class="tt">NULL</span> is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01444">1444</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a84cfd8fc36e1ba98ab427d82802ad420" name="a84cfd8fc36e1ba98ab427d82802ad420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cfd8fc36e1ba98ab427d82802ad420">&#9670;&#160;</a></span>sht_iter_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sht_iter_delete </td>
          <td>(</td>
          <td class="paramtype">struct sht_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the last entry returned by a <b>read/write</b> iterator. </p>
<blockquote class="doxtable">
<p><b>NOTE</b></p>
<p>This function cannot be called on a read-only iterator. (See <a class="el" href="index.html#abort-conditions">Abort conditions</a>.) </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true (<span class="tt">1</span>) is returned. On error, false (<span class="tt">0</span>) is returned and the error status of the iterator is set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01484">1484</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="a65154d9195575fab4ad984fbbcfaf13d" name="a65154d9195575fab4ad984fbbcfaf13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65154d9195575fab4ad984fbbcfaf13d">&#9670;&#160;</a></span>sht_iter_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sht_iter_replace </td>
          <td>(</td>
          <td class="paramtype">struct sht_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the last entry returned by an iterator. </p>
<blockquote class="doxtable">
<p><b>WARNING</b></p>
<p>The new entry <b>must</b> have the same key as the entry being replaced. Replacing an entry with an entry that contains a different key will corrupt the table. </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator. </td></tr>
    <tr><td class="paramname">entry</td><td>The new entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, true (<span class="tt">1</span>) is returned. On error, false (<span class="tt">0</span>) is returned and the error status of the iterator is set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01521">1521</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
<a id="ac3f4b138ac33ecb1bbb59aa4a73354f8" name="ac3f4b138ac33ecb1bbb59aa4a73354f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f4b138ac33ecb1bbb59aa4a73354f8">&#9670;&#160;</a></span>sht_iter_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sht_iter_free </td>
          <td>(</td>
          <td class="paramtype">struct sht_iter *</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sht_8c_source.html#l01541">1541</a> of file <a class="el" href="sht_8c_source.html">sht.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>src</b></li><li class="navelem"><a href="sht_8c.html">sht.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
