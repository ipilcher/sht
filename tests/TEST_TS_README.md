# Hash Table Type-Safe API Test Suite

**NOTE:** This test suite was generated by Claude Code, Anthropic's official CLI for Claude AI.

## Overview

Type-safe API test suite for the SHT hash table library. The test suite demonstrates usage of the type-safe API provided by `sht-ts.h` and verifies correct functionality through compile-time type checking and runtime validation.

## Building and Running

```bash
make sht_ts_test
./sht_ts_test
```

Or separately:

```bash
make test_ts
```

## Key Differences from Regular API

### Type-Safe Table Types

The type-safe API uses the `SHT_TABLE_TYPE` macro to generate table-specific types and functions:

```c
/* Define entry type */
struct int_entry {
    int key;
    int value;
};

/* Define type-safe callback functions */
static uint32_t int_tbl_hashfn(const int *restrict key);
static _Bool int_tbl_eqfn(const int *restrict key, const struct int_entry *restrict entry);

/* Generate type-safe API */
SHT_TABLE_TYPE(
    int_tbl,            /* prefix for generated functions */
    int,                /* key type */
    struct int_entry,   /* entry type */
    int_tbl_hashfn,     /* hash function */
    int_tbl_eqfn        /* equality function */
)
```

This generates:
- Type: `struct int_tbl_ht` (table type)
- Type: `struct int_tbl_iter` (iterator type)
- Functions: `int_tbl_new()`, `int_tbl_init()`, `int_tbl_add()`, `int_tbl_get()`, etc.

### Compile-Time Type Checking

The type-safe API provides:

1. **Type-safe function signatures**: Callback functions have concrete types instead of `void *`
2. **Signature validation**: Compile-time checks verify callback signatures match expected types
3. **No casts required**: Application code works with actual types, not void pointers

### Example Comparison

**Regular API:**
```c
struct sht_ht *ht = SHT_NEW(hashfn, eqfn, NULL, struct entry);
sht_add(ht, &key, &entry);  // All pointers are void *
const void *result = sht_get(ht, &key);  // Returns void *, requires cast
```

**Type-Safe API:**
```c
struct int_tbl_ht *ht = int_tbl_new();
int_tbl_add(ht, &key, &entry);  // Type-checked pointers
const struct int_entry *result = int_tbl_get(ht, &key);  // Returns concrete type
```

## Test Coverage

**Total: 90 tests (100% of original test suite)**

### 1. Basic Creation and Initialization (7 tests)
- ✓ Create without error pointer
- ✓ Create and free table
- ✓ Create with initial capacity
- ✓ Entry size validation (too large) - uses `sht_new_()` to test runtime validation
- ✓ Entry size at maximum (16KiB)
- ✓ Capacity validation (too large)
- ✓ Unusual alignment requirements

### 2. Table State Query Operations (6 tests)
- ✓ Size of empty table
- ✓ Size with entries (verify after each add)
- ✓ Size after deletion operations
- ✓ Empty status on initial table
- ✓ Empty status with entries
- ✓ Empty status after clearing all entries

### 3. Context and Configuration (5 tests)
- ✓ Hash function context
- ✓ Equality function context
- ✓ Free function context
- ✓ Load factor threshold configuration
- ✓ PSL threshold configuration

### 4. Add Operations (3 tests)
- ✓ Add new entry
- ✓ Add duplicate entry (should not replace)
- ✓ Add multiple entries

### 5. Set Operations (3 tests)
- ✓ Set new entry
- ✓ Set existing entry (should replace)
- ✓ Set with free function (resource cleanup)

### 6. Get Operations (2 tests)
- ✓ Get existing entry
- ✓ Get nonexistent entry

### 7. Replace Operations (2 tests)
- ✓ Replace existing entry
- ✓ Replace nonexistent entry (should fail)

### 8. Swap Operations (3 tests)
- ✓ Swap existing entry (return old value)
- ✓ Swap nonexistent entry (should fail)
- ✓ Swap with separate buffers

### 9. Delete Operations (4 tests)
- ✓ Delete existing entry
- ✓ Delete nonexistent entry
- ✓ Pop existing entry (return value)
- ✓ Pop nonexistent entry

### 10. Table Growth and Collision Handling (7 tests)
- ✓ Table growth and rehashing (1000 entries from initial capacity of 2)
- ✓ Collision handling (50 entries with pathological hash function)
- ✓ Excessive collisions with default PSL threshold (127)
- ✓ Excessive collisions with PSL threshold of 10
- ✓ Excessive collisions with PSL threshold of 50
- ✓ Excessive collisions with PSL threshold of 1
- ✓ PSL tracking after deletion operations

### 11. Read-Only Iterators (5 tests)
- ✓ Iterate over empty table
- ✓ Iterate over all entries (100 entries)
- ✓ Multiple concurrent read-only iterators
- ✓ Maximum iterator count (32767 iterators)
- ✓ Replace entry via read-only iterator

### 12. Read/Write Iterators (8 tests)
- ✓ Iterate over empty table
- ✓ Read/write iterator exclusivity (blocks other iterators)
- ✓ Read-only iterator blocks read/write iterator
- ✓ Delete entries via read/write iterator
- ✓ Replace entries via read/write iterator
- ✓ Delete without calling next (error condition)
- ✓ Replace without calling next (error condition)
- ✓ Iterator error message verification

### 13. Edge Cases and Stress Tests (3 tests)
- ✓ Delete and re-add entries repeatedly
- ✓ Wraparound deletion (Robin Hood probing edge case)
- ✓ String keys with dynamic memory allocation

### 14. Abort Conditions (32 tests)
- ✓ Invalid error code
- ✓ Entry alignment not a power of 2
- ✓ Incompatible entry size and alignment
- ✓ NULL hash function pointer
- ✓ NULL equality function pointer
- ✓ Set hash context after initialization
- ✓ Set equality context after initialization
- ✓ Set free context after initialization
- ✓ Set load factor threshold after initialization
- ✓ Set load factor threshold (invalid low: 0)
- ✓ Set load factor threshold (invalid high: 101)
- ✓ Set PSL threshold after initialization
- ✓ Set PSL threshold (invalid low: 0)
- ✓ Set PSL threshold (invalid high: 128)
- ✓ Initialize table twice
- ✓ Query size before initialization
- ✓ Query empty status before initialization
- ✓ Get entry before initialization
- ✓ Add entry before initialization
- ✓ Set entry before initialization
- ✓ Replace entry before initialization
- ✓ Swap entry before initialization
- ✓ Pop entry before initialization
- ✓ Delete entry before initialization
- ✓ Create read-only iterator before initialization
- ✓ Create read/write iterator before initialization
- ✓ Add entry with active iterator
- ✓ Set entry with active iterator
- ✓ Pop entry with active iterator
- ✓ Delete entry with active iterator
- ✓ Free table with active iterator
- ✓ Delete via read-only iterator

## Test Entry Types

The test suite uses multiple entry types to verify type safety:

1. **String entries** (`struct str_entry`) - Dynamic allocation with free function
2. **Integer entries** (`struct int_entry`) - Simple numeric key/value pairs
3. **Large entries** (`struct large_entry`) - Maximum size (16KiB)
4. **Aligned entries** (`struct aligned_entry`) - Unusual alignment (64-byte)

## Type-Safe Table Types Generated

The test suite defines several table types using `SHT_TABLE_TYPE`:

- `str` - String table with free function
- `int_tbl` - Integer table without free function
- `large` - Large entry table (max size testing)
- `aligned` - Aligned entry table (alignment testing)
- `ctx_hash` - Table with hash function context
- `ctx_eq` - Table with equality function context
- `ctx_free` - Table with free function context
- `bad` - Bad hash table for collision testing

Note: Multiple table types can share the same callback functions. For example, `int_tbl`, `large`, `ctx_eq`, `ctx_free`, and `bad` all use the shared `int_hashfn` function.

## Type-Safe Callback Functions

Each table type requires type-specific callback functions:

```c
/* Hash function: returns hash of key */
static uint32_t prefix_hashfn(const KeyType *restrict key);

/* Equality function: compares key with entry */
static _Bool prefix_eqfn(const KeyType *restrict key,
                         const EntryType *restrict entry);

/* Free function (optional): frees resources in entry */
static void prefix_freefn(const EntryType *restrict entry);
```

### With Context

Functions can also accept a context parameter:

```c
/* Hash function with context */
static uint32_t prefix_hashfn(const KeyType *restrict key,
                              const CtxType *restrict context);

/* Equality function with context */
static _Bool prefix_eqfn(const KeyType *restrict key,
                        const EntryType *restrict entry,
                        const CtxType *restrict context);

/* Free function with context */
static void prefix_freefn(const EntryType *restrict entry,
                         const CtxType *restrict context);
```

## Hash Functions Used

1. **XXH3_64bits** - Standard fast hash (for most tables)
2. **XXH32** - Hash with seed (context testing)
3. **Constant hash** - Returns 0 (collision testing)

## Notes

- All tests use assertions for validation
- Memory leaks are prevented through proper cleanup
- Tests are independent and can run in any order
- The type-safe API provides compile-time checking via `_Generic` and `static_assert`
- Each `SHT_TABLE_TYPE` invocation generates unique wrapper functions
- Wrapper functions perform signature validation at compile time
- Callback functions can be shared between multiple table types (the wrapper function names are unique per table type)

## Advantages of Type-Safe API

1. **Compile-time type checking** - Catch type mismatches at compile time
2. **No casts required** - Work with concrete types throughout
3. **Better IDE support** - Type information enables better autocomplete
4. **Signature validation** - Compiler verifies callback signatures match expected types
5. **Self-documenting** - Function signatures clearly show expected types

## Implementation Notes

- **Function sharing**: Callback functions can be shared between table types - the generated wrapper functions have unique names based on the table type prefix
- **Macro expansion**: `SHT_TABLE_TYPE` generates all wrapper functions at the point of invocation
- **Storage class**: Optionally specify storage class (e.g., `static`) for generated functions
- **Context types**: Context parameters support both `const` and non-`const` pointer types
- **Free function**: Specified in `SHT_TABLE_TYPE`, not via a separate setter function
