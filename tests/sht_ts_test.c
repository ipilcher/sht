// SPDX-License-Identifier: GPL-3.0-or-later

/*
 *
 * 	SHT - hash table with "Robin Hood" probing
 *
 * 	Hash table type-safe API comprehensive test suite
 *
 *	Copyright 2025 Ian Pilcher <arequipeno@gmail.com>
 *
 *	NOTE: This test suite was generated by Claude Code, Anthropic's
 *	      official CLI for Claude AI.
 *
 */

#include "../src/sht-ts.h"

#include <assert.h>
#include <inttypes.h>
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <xxhash.h>

/*******************************************************************************
 *
 *	Test framework
 *
 ******************************************************************************/

static unsigned int tests_run = 0;
static unsigned int tests_passed = 0;
static unsigned int tests_failed = 0;

#define TEST(name) \
	static void test_##name(void); \
	static void run_##name(void) { \
		printf("Running test: %s ... ", #name); \
		fflush(stdout); \
		tests_run++; \
		test_##name(); \
		tests_passed++; \
		printf("PASSED\n"); \
	} \
	static void test_##name(void)

#define ASSERT(cond) \
	do { \
		if (!(cond)) { \
			printf("FAILED\n  %s:%d: assertion failed: %s\n", \
			       __FILE__, __LINE__, #cond); \
			tests_failed++; \
			return; \
		} \
	} while (0)

#define RUN_TEST(name) run_##name()

/*******************************************************************************
 *
 *	Abort condition testing infrastructure
 *
 ******************************************************************************/

static jmp_buf abort_jmp_buf;
static const char *abort_msg_received = NULL;
static void (*saved_abort_print)(const char *) = NULL;

static void test_abort_handler(const char *msg)
{
	abort_msg_received = msg;
	longjmp(abort_jmp_buf, 1);
}

static void setup_abort_test(void)
{
	saved_abort_print = sht_abort_print;
	sht_abort_print = test_abort_handler;
	abort_msg_received = NULL;
}

static void teardown_abort_test(void)
{
	sht_abort_print = saved_abort_print;
	abort_msg_received = NULL;
}

#define ASSERT_ABORTS(code, expected_msg_substr) \
	do { \
		setup_abort_test(); \
		if (setjmp(abort_jmp_buf) == 0) { \
			code; \
			teardown_abort_test(); \
			printf("FAILED\n  %s:%d: expected abort but didn't happen\n", \
			       __FILE__, __LINE__); \
			tests_failed++; \
			return; \
		} \
		ASSERT(abort_msg_received != NULL); \
		ASSERT(strstr(abort_msg_received, expected_msg_substr) != NULL); \
		teardown_abort_test(); \
	} while (0)

/*******************************************************************************
 *
 *	Test entry types
 *
 ******************************************************************************/

/* Simple string key/value entry */
struct str_entry {
	char *key;
	char *value;
};

/* Integer key/value entry */
struct int_entry {
	int key;
	int value;
};

/* Large entry (to test size limits) */
struct large_entry {
	char data[16384];  /* Maximum size */
};

/* Over-sized entry (to test error handling) */
struct oversized_entry {
	char data[16385];  /* Too large */
};

/* Entry with unusual alignment */
struct __attribute__((aligned(64))) aligned_entry {
	int value;
};

/*******************************************************************************
 *
 *	Type-safe hash and comparison functions
 *
 ******************************************************************************/

/* String hash function */
static uint32_t str_hashfn(const char *restrict key)
{
	return XXH3_64bits(key, strlen(key));
}

/* String equality function */
static _Bool str_eqfn(const char *restrict key, const struct str_entry *restrict entry)
{
	return strcmp(key, entry->key) == 0;
}

/* String free function */
static void str_freefn(const struct str_entry *restrict entry)
{
	free(entry->key);
	free(entry->value);
}

/* Integer hash function (shared by multiple table types) */
static uint32_t int_hashfn(const int *restrict key)
{
	return XXH3_64bits(key, sizeof(*key));
}

/* Integer equality function (shared by multiple table types) */
static _Bool int_eqfn(const int *restrict key, const struct int_entry *restrict entry)
{
	return *key == entry->key;
}

/* Large entry equality function (dummy - always returns true) */
static _Bool large_eqfn(const int *restrict key, const struct large_entry *restrict entry)
{
	(void)entry;
	(void)key;
	/* Large entries don't have a real key, just testing size */
	return 1;
}

/* Aligned entry equality function (uses entry->value instead of entry->key) */
static _Bool aligned_eqfn(const int *restrict key, const struct aligned_entry *restrict entry)
{
	return *key == entry->value;
}

/* Pathological hash function that always returns 0 (tests collision handling) */
static uint32_t bad_hashfn(const int *restrict key)
{
	(void)key;
	return 0;
}

/* Hash function with context (uses seed parameter) */
static uint32_t ctx_hashfn(const int *restrict key, const uint32_t *restrict seed)
{
	return XXH32(key, sizeof(*key), *seed);
}

/* Equality function with context (sets flag when called with context) */
static int eq_context_used = 0;

static _Bool ctx_eq_eqfn(const int *restrict key, const struct int_entry *restrict entry,
			 const int *restrict ctx)
{
	if (ctx != NULL)
		eq_context_used = 1;
	return *key == entry->key;
}

/* Free function with context (sets flag when called with context) */
static int free_context_used = 0;

static void ctx_freefn(const struct int_entry *restrict entry, const int *restrict ctx)
{
	(void)entry;
	if (ctx != NULL)
		free_context_used = 1;
}

/*******************************************************************************
 *
 *	Type-safe table type definitions
 *
 ******************************************************************************/

/* String table with free function */
SHT_TABLE_TYPE(
	str,			/* prefix */
	char,			/* key type */
	struct str_entry,	/* entry type */
	str_hashfn,		/* hash function */
	str_eqfn,		/* equality function */
	str_freefn		/* free function */
)

/* Integer table without free function */
SHT_TABLE_TYPE(
	int_tbl,		/* prefix */
	int,			/* key type */
	struct int_entry,	/* entry type */
	int_hashfn,		/* hash function */
	int_eqfn		/* equality function */
)

/* Large entry table */
SHT_TABLE_TYPE(
	large,			/* prefix */
	int,			/* key type */
	struct large_entry,	/* entry type */
	int_hashfn,		/* hash function */
	large_eqfn		/* equality function */
)

/* Aligned entry table */
SHT_TABLE_TYPE(
	aligned,		/* prefix */
	int,			/* key type */
	struct aligned_entry,	/* entry type */
	int_hashfn,		/* hash function */
	aligned_eqfn		/* equality function */
)

/* Table with hash function context */
SHT_TABLE_TYPE(
	ctx_hash,		/* prefix */
	int,			/* key type */
	struct int_entry,	/* entry type */
	(ctx_hashfn, const uint32_t),	/* hash function, context type */
	int_eqfn		/* equality function */
)

/* Table with equality function context */
SHT_TABLE_TYPE(
	ctx_eq,			/* prefix */
	int,			/* key type */
	struct int_entry,	/* entry type */
	int_hashfn,		/* hash function */
	(ctx_eq_eqfn, const int)	/* equality function, context type */
)

/* Table with free function context */
SHT_TABLE_TYPE(
	ctx_free,		/* prefix */
	int,			/* key type */
	struct int_entry,	/* entry type */
	int_hashfn,		/* hash function */
	int_eqfn,		/* equality function */
	(ctx_freefn, const int)	/* free function, context type */
)

/* Bad hash table for collision testing */
SHT_TABLE_TYPE(
	bad,			/* prefix */
	int,			/* key type */
	struct int_entry,	/* entry type */
	bad_hashfn,		/* hash function */
	int_eqfn		/* equality function */
)

/*******************************************************************************
 *
 *	Tests: Basic table creation and initialization
 *
 ******************************************************************************/

TEST(create_without_err_pointer)
{
	struct str_ht *ht;

	ht = str_new();
	ASSERT(ht != NULL);
	ASSERT(str_init(ht, 0));
	str_free(ht);
}

TEST(create_and_free)
{
	struct str_ht *ht;

	ht = str_new();
	ASSERT(ht != NULL);
	ASSERT(str_init(ht, 0));
	str_free(ht);
}

TEST(create_with_capacity)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 100));
	int_tbl_free(ht);
}

/* Raw hash function for direct sht_new_() testing */
static uint32_t raw_hashfn(const void *restrict key, void *restrict ctx)
{
	(void)ctx;
	const int *k = key;
	return XXH3_64bits(k, sizeof(*k));
}

/* Raw equality function for direct sht_new_() testing */
static _Bool raw_eqfn(const void *restrict key, const void *restrict entry,
		      void *restrict ctx)
{
	(void)ctx;
	const int *k = key;
	const struct int_entry *e = entry;
	return *k == e->key;
}

TEST(entry_size_too_large)
{
	struct sht_ht *ht;
	enum sht_err err = SHT_ERR_OK;

	/* Call sht_new_() directly to test runtime validation.
	   (SHT_TABLE_TYPE has compile-time validation that would fail here.) */
	ht = sht_new_(raw_hashfn, raw_eqfn, NULL, sizeof(struct oversized_entry),
		      _Alignof(struct oversized_entry), &err);
	ASSERT(ht == NULL);
	ASSERT(err == SHT_ERR_BAD_ESIZE);
	ASSERT(strcmp(sht_msg(err), "Entry size too large (> 16KiB)") == 0);
}

TEST(entry_size_maximum)
{
	struct large_ht *ht;

	ht = large_new();
	ASSERT(ht != NULL);
	ASSERT(large_init(ht, 0));
	large_free(ht);
}

TEST(capacity_too_large)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(!int_tbl_init(ht, UINT32_C(1) << 25));  /* > 16,777,216 */
	ASSERT(int_tbl_get_err(ht) == SHT_ERR_TOOBIG);
	ASSERT(strcmp(int_tbl_get_msg(ht), "Requested table size too large") == 0);
	int_tbl_free(ht);
}

TEST(unusual_alignment)
{
	struct aligned_ht *ht;

	ht = aligned_new();
	ASSERT(ht != NULL);
	ASSERT(aligned_init(ht, 0));
	aligned_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Table state query operations
 *
 ******************************************************************************/

TEST(size_empty_table)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	ASSERT(int_tbl_size(ht) == 0);

	int_tbl_free(ht);
}

TEST(size_with_entries)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int i;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	/* Add entries and verify size */
	for (i = 0; i < 100; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(int_tbl_add(ht, &e.key, &e) == 0);
		ASSERT(int_tbl_size(ht) == (uint32_t)(i + 1));
	}

	int_tbl_free(ht);
}

TEST(size_after_delete)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int i;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	/* Add entries */
	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(int_tbl_add(ht, &e.key, &e) == 0);
	}
	ASSERT(int_tbl_size(ht) == 10);

	/* Delete entries and verify size */
	for (i = 0; i < 5; i++) {
		ASSERT(int_tbl_delete(ht, &i));
		ASSERT(int_tbl_size(ht) == (uint32_t)(10 - i - 1));
	}
	ASSERT(int_tbl_size(ht) == 5);

	int_tbl_free(ht);
}

TEST(empty_initial_table)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	ASSERT(int_tbl_empty(ht) == 1);

	int_tbl_free(ht);
}

TEST(empty_with_entries)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	ASSERT(int_tbl_empty(ht) == 1);

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	ASSERT(int_tbl_empty(ht) == 0);

	int_tbl_free(ht);
}

TEST(empty_after_clear)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int i;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	/* Add entries */
	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(int_tbl_add(ht, &e.key, &e) == 0);
	}
	ASSERT(int_tbl_empty(ht) == 0);

	/* Delete all entries */
	for (i = 0; i < 10; i++) {
		ASSERT(int_tbl_delete(ht, &i));
	}
	ASSERT(int_tbl_empty(ht) == 1);

	int_tbl_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Context and configuration functions
 *
 ******************************************************************************/

TEST(hash_context)
{
	struct ctx_hash_ht *ht;
	uint32_t seed = 42;

	ht = ctx_hash_new();
	ASSERT(ht != NULL);
	ctx_hash_set_hash_ctx(ht, &seed);
	ASSERT(ctx_hash_init(ht, 0));

	/* Just verify it doesn't crash - hard to test hash context without
	   examining internal state */
	struct int_entry e = { .key = 1, .value = 100 };
	int key = 1;
	ASSERT(ctx_hash_add(ht, &key, &e) == 0);

	ctx_hash_free(ht);
}

TEST(eq_context)
{
	struct ctx_eq_ht *ht;
	int ctx = 1;

	eq_context_used = 0;
	ht = ctx_eq_new();
	ASSERT(ht != NULL);
	ctx_eq_set_eq_ctx(ht, &ctx);
	ASSERT(ctx_eq_init(ht, 0));

	struct int_entry e = { .key = 1, .value = 100 };
	int key = 1;
	ASSERT(ctx_eq_add(ht, &key, &e) == 0);
	ASSERT(ctx_eq_get(ht, &key) != NULL);
	ASSERT(eq_context_used == 1);

	ctx_eq_free(ht);
}

TEST(free_context)
{
	struct ctx_free_ht *ht;
	int ctx = 1;

	free_context_used = 0;
	ht = ctx_free_new();
	ASSERT(ht != NULL);
	ctx_free_set_free_ctx(ht, &ctx);
	ASSERT(ctx_free_init(ht, 0));

	struct int_entry e = { .key = 1, .value = 100 };
	int key = 1;
	ASSERT(ctx_free_add(ht, &key, &e) == 0);

	ctx_free_free(ht);
	ASSERT(free_context_used == 1);
}

TEST(load_factor_threshold)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	int_tbl_set_lft(ht, 50);  /* 50% load factor */
	ASSERT(int_tbl_init(ht, 0));
	int_tbl_free(ht);
}

TEST(psl_threshold)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	int_tbl_set_psl_limit(ht, 100);  /* PSL threshold of 100 */
	ASSERT(int_tbl_init(ht, 0));
	int_tbl_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Add operations
 *
 ******************************************************************************/

TEST(add_new_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);  /* New entry */

	int_tbl_free(ht);
}

TEST(add_duplicate_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e1, e2;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e1.key = 42;
	e1.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e1) == 0);  /* New entry */

	e2.key = 42;
	e2.value = 200;
	ASSERT(int_tbl_add(ht, &key, &e2) == 1);  /* Duplicate - not added */

	const struct int_entry *result = int_tbl_get(ht, &key);
	ASSERT(result != NULL);
	ASSERT(result->value == 100);  /* Original value unchanged */

	int_tbl_free(ht);
}

TEST(add_multiple_entries)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int i;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	for (i = 0; i < 100; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(int_tbl_add(ht, &e.key, &e) == 0);
	}

	/* Verify all entries */
	for (i = 0; i < 100; i++) {
		const struct int_entry *result = int_tbl_get(ht, &i);
		ASSERT(result != NULL);
		ASSERT(result->key == i);
		ASSERT(result->value == i * 10);
	}

	int_tbl_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Set operations
 *
 ******************************************************************************/

TEST(set_new_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_set(ht, &key, &e) == 0);  /* New entry */

	int_tbl_free(ht);
}

TEST(set_replace_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e1, e2;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e1.key = 42;
	e1.value = 100;
	ASSERT(int_tbl_set(ht, &key, &e1) == 0);  /* New entry */

	e2.key = 42;
	e2.value = 200;
	ASSERT(int_tbl_set(ht, &key, &e2) == 1);  /* Replace */

	const struct int_entry *result = int_tbl_get(ht, &key);
	ASSERT(result != NULL);
	ASSERT(result->value == 200);  /* Updated value */

	int_tbl_free(ht);
}

TEST(set_with_freefn)
{
	struct str_ht *ht;
	struct str_entry e1, e2;
	const char *key = "test";

	ht = str_new();
	ASSERT(ht != NULL);
	ASSERT(str_init(ht, 0));

	e1.key = strdup("test");
	e1.value = strdup("value1");
	ASSERT(str_set(ht, key, &e1) == 0);

	e2.key = strdup("test");
	e2.value = strdup("value2");
	ASSERT(str_set(ht, key, &e2) == 1);  /* Should free e1's strings */

	str_free(ht);  /* Should free e2's strings */
}

/*******************************************************************************
 *
 *	Tests: Get operations
 *
 ******************************************************************************/

TEST(get_existing_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	const struct int_entry *result = int_tbl_get(ht, &key);
	ASSERT(result != NULL);
	ASSERT(result->key == 42);
	ASSERT(result->value == 100);

	int_tbl_free(ht);
}

TEST(get_nonexistent_entry)
{
	struct int_tbl_ht *ht;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	const struct int_entry *result = int_tbl_get(ht, &key);
	ASSERT(result == NULL);

	int_tbl_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Replace operations
 *
 ******************************************************************************/

TEST(replace_existing_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e1, e2;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e1.key = 42;
	e1.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e1) == 0);

	e2.key = 42;
	e2.value = 200;
	ASSERT(int_tbl_replace(ht, &key, &e2));

	const struct int_entry *result = int_tbl_get(ht, &key);
	ASSERT(result != NULL);
	ASSERT(result->value == 200);

	int_tbl_free(ht);
}

TEST(replace_nonexistent_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(!int_tbl_replace(ht, &key, &e));

	int_tbl_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Swap operations
 *
 ******************************************************************************/

TEST(swap_existing_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e1, e2;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e1.key = 42;
	e1.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e1) == 0);

	e2.key = 42;
	e2.value = 200;
	ASSERT(int_tbl_swap(ht, &key, &e2, &e2));
	ASSERT(e2.key == 42);
	ASSERT(e2.value == 100);  /* Old value */

	const struct int_entry *result = int_tbl_get(ht, &key);
	ASSERT(result != NULL);
	ASSERT(result->value == 200);

	int_tbl_free(ht);
}

TEST(swap_nonexistent_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(!int_tbl_swap(ht, &key, &e, &e));

	int_tbl_free(ht);
}

TEST(swap_separate_buffers)
{
	struct int_tbl_ht *ht;
	struct int_entry e1, e2, old;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e1.key = 42;
	e1.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e1) == 0);

	e2.key = 42;
	e2.value = 200;
	ASSERT(int_tbl_swap(ht, &key, &e2, &old));
	ASSERT(old.value == 100);
	ASSERT(e2.value == 200);  /* Unchanged */

	int_tbl_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Delete operations
 *
 ******************************************************************************/

TEST(delete_existing_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);
	ASSERT(int_tbl_delete(ht, &key));
	ASSERT(int_tbl_get(ht, &key) == NULL);

	int_tbl_free(ht);
}

TEST(delete_nonexistent_entry)
{
	struct int_tbl_ht *ht;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	ASSERT(!int_tbl_delete(ht, &key));

	int_tbl_free(ht);
}

TEST(pop_existing_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry e, popped;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);
	ASSERT(int_tbl_pop(ht, &key, &popped));
	ASSERT(popped.key == 42);
	ASSERT(popped.value == 100);
	ASSERT(int_tbl_get(ht, &key) == NULL);

	int_tbl_free(ht);
}

TEST(pop_nonexistent_entry)
{
	struct int_tbl_ht *ht;
	struct int_entry popped;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	ASSERT(!int_tbl_pop(ht, &key, &popped));

	int_tbl_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Table growth and collision handling
 *
 ******************************************************************************/

TEST(table_growth)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int i;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 2));  /* Very small initial size */

	/* Add enough entries to force multiple rehashes */
	for (i = 0; i < 1000; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(int_tbl_add(ht, &e.key, &e) == 0);
	}

	/* Verify all entries survived rehashing */
	for (i = 0; i < 1000; i++) {
		const struct int_entry *result = int_tbl_get(ht, &i);
		ASSERT(result != NULL);
		ASSERT(result->key == i);
		ASSERT(result->value == i * 10);
	}

	int_tbl_free(ht);
}

TEST(collision_handling)
{
	struct bad_ht *ht;
	struct int_entry e;
	int i;

	/* Use pathological hash function to force collisions */
	ht = bad_new();
	ASSERT(ht != NULL);
	ASSERT(bad_init(ht, 0));

	/* Add entries that will all hash to the same value */
	for (i = 0; i < 50; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(bad_add(ht, &e.key, &e) == 0);
	}

	/* Verify all entries can be retrieved */
	for (i = 0; i < 50; i++) {
		const struct int_entry *result = bad_get(ht, &i);
		ASSERT(result != NULL);
		ASSERT(result->key == i);
		ASSERT(result->value == i * 10);
	}

	bad_free(ht);
}

TEST(excessive_collisions)
{
	struct bad_ht *ht;
	struct int_entry e;
	int i;
	int result;

	/* Use pathological hash function and small table */
	ht = bad_new();
	ASSERT(ht != NULL);
	bad_set_lft(ht, 95);  /* High load factor to delay growth */
	ASSERT(bad_init(ht, 128));

	/* Add entries until we exceed max PSL (127) - this MUST happen
	   because bad_hashfn forces all entries to the same bucket */
	for (i = 0; i < 200; i++) {
		e.key = i;
		e.value = i * 10;
		result = bad_add(ht, &e.key, &e);
		if (result == -1) {
			ASSERT(bad_get_err(ht) == SHT_ERR_BAD_HASH);
			bad_free(ht);
			return;
		}
	}

	/* Should never get here - bad_hashfn forces PSL limit */
	ASSERT(0 && "Should have hit SHT_ERR_BAD_HASH");
	bad_free(ht);
}

TEST(excessive_collisions_psl_10)
{
	struct bad_ht *ht;
	struct int_entry e;
	int i;
	int result;

	/* Use pathological hash function with low PSL threshold */
	ht = bad_new();
	ASSERT(ht != NULL);
	bad_set_lft(ht, 95);  /* High load factor to delay growth */
	bad_set_psl_limit(ht, 10);  /* Low PSL threshold */
	ASSERT(bad_init(ht, 32));

	/* Add entries until we hit the PSL limit - this MUST happen
	   because bad_hashfn forces all entries to the same bucket */
	for (i = 0; i < 50; i++) {
		e.key = i;
		e.value = i * 10;
		result = bad_add(ht, &e.key, &e);
		if (result == -1) {
			ASSERT(bad_get_err(ht) == SHT_ERR_BAD_HASH);
			bad_free(ht);
			return;
		}
	}

	/* Should never get here - bad_hashfn forces PSL limit */
	ASSERT(0 && "Should have hit SHT_ERR_BAD_HASH");
	bad_free(ht);
}

TEST(excessive_collisions_psl_50)
{
	struct bad_ht *ht;
	struct int_entry e;
	int i;
	int result;

	/* Use pathological hash function with medium PSL threshold */
	ht = bad_new();
	ASSERT(ht != NULL);
	bad_set_lft(ht, 95);  /* High load factor to delay growth */
	bad_set_psl_limit(ht, 50);  /* Medium PSL threshold */
	ASSERT(bad_init(ht, 64));

	/* Add entries until we hit the PSL limit - this MUST happen
	   because bad_hashfn forces all entries to the same bucket */
	for (i = 0; i < 100; i++) {
		e.key = i;
		e.value = i * 10;
		result = bad_add(ht, &e.key, &e);
		if (result == -1) {
			ASSERT(bad_get_err(ht) == SHT_ERR_BAD_HASH);
			bad_free(ht);
			return;
		}
	}

	/* Should never get here - bad_hashfn forces PSL limit */
	ASSERT(0 && "Should have hit SHT_ERR_BAD_HASH");
	bad_free(ht);
}

TEST(excessive_collisions_psl_1)
{
	struct bad_ht *ht;
	struct int_entry e;
	int i;
	int result;

	/* Use pathological hash function with minimal PSL threshold */
	ht = bad_new();
	ASSERT(ht != NULL);
	bad_set_lft(ht, 95);  /* High load factor to delay growth */
	bad_set_psl_limit(ht, 1);  /* Minimal PSL threshold */
	ASSERT(bad_init(ht, 16));

	/* Add entries until we hit the PSL limit - this MUST happen
	   because bad_hashfn forces all entries to the same bucket */
	for (i = 0; i < 20; i++) {
		e.key = i;
		e.value = i * 10;
		result = bad_add(ht, &e.key, &e);
		if (result == -1) {
			ASSERT(bad_get_err(ht) == SHT_ERR_BAD_HASH);
			bad_free(ht);
			return;
		}
	}

	/* Should never get here - bad_hashfn forces PSL limit */
	ASSERT(0 && "Should have hit SHT_ERR_BAD_HASH");
	bad_free(ht);
}

TEST(psl_tracking_after_delete)
{
	struct bad_ht *ht;
	struct int_entry e;
	int keys[20];
	int i;
	int result;

	/* Use pathological hash with very low PSL threshold */
	ht = bad_new();
	ASSERT(ht != NULL);
	bad_set_lft(ht, 95);  /* High load factor to prevent growth */
	bad_set_psl_limit(ht, 3);  /* Very low PSL threshold */
	ASSERT(bad_init(ht, 16));

	/* Add entries to create a chain up to PSL threshold */
	for (i = 0; i < 10; i++) {
		keys[i] = i;
		e.key = i;
		e.value = i * 10;
		result = bad_add(ht, &keys[i], &e);
		if (result == -1) {
			ASSERT(bad_get_err(ht) == SHT_ERR_BAD_HASH);
			break;
		}
	}

	/* If we successfully added entries, try deleting and re-adding
	   to test psl_maxxed tracking after deletions */
	if (i > 0) {
		/* Delete the last entry added */
		bad_delete(ht, &keys[i - 1]);

		/* Try to add more entries - should still respect PSL limit */
		for (; i < 20; i++) {
			keys[i] = i;
			e.key = i;
			e.value = i * 10;
			result = bad_add(ht, &keys[i], &e);
			if (result == -1) {
				ASSERT(bad_get_err(ht) == SHT_ERR_BAD_HASH);
				break;
			}
		}
	}

	bad_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Read-only iterators
 *
 ******************************************************************************/

TEST(ro_iterator_empty_table)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter != NULL);
	ASSERT(int_tbl_iter_next(iter) == NULL);
	int_tbl_iter_free(iter);

	int_tbl_free(ht);
}

TEST(ro_iterator_all_entries)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e;
	const struct int_entry *result;
	int i, count;
	int seen[100] = {0};

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	for (i = 0; i < 100; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(int_tbl_add(ht, &e.key, &e) == 0);
	}

	iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter != NULL);

	count = 0;
	while ((result = int_tbl_iter_next(iter)) != NULL) {
		ASSERT(result->key >= 0 && result->key < 100);
		ASSERT(result->value == result->key * 10);
		ASSERT(seen[result->key] == 0);
		seen[result->key] = 1;
		count++;
	}
	ASSERT(count == 100);

	int_tbl_iter_free(iter);
	int_tbl_free(ht);
}

TEST(multiple_ro_iterators)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter1, *iter2;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	iter1 = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter1 != NULL);

	iter2 = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter2 != NULL);

	int_tbl_iter_free(iter1);
	int_tbl_iter_free(iter2);

	int_tbl_free(ht);
}

TEST(ro_iterator_max_count)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iters[32767];  /* SHT_MAX_ITERS */
	struct int_entry e;
	int i, key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	/* Create maximum number of iterators */
	for (i = 0; i < 32767; i++) {
		iters[i] = int_tbl_iter_new(ht, SHT_ITER_RO);
		ASSERT(iters[i] != NULL);
	}

	/* Try to create one more - should fail */
	struct int_tbl_iter *extra = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(extra == NULL);
	ASSERT(int_tbl_get_err(ht) == SHT_ERR_ITER_COUNT);

	/* Free all iterators */
	for (i = 0; i < 32767; i++) {
		int_tbl_iter_free(iters[i]);
	}

	int_tbl_free(ht);
}

TEST(ro_iterator_replace)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e;
	const struct int_entry *result;
	int i;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(int_tbl_add(ht, &e.key, &e) == 0);
	}

	iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter != NULL);

	/* Get first entry and replace it */
	result = int_tbl_iter_next(iter);
	ASSERT(result != NULL);

	e.key = result->key;
	e.value = 9999;
	ASSERT(int_tbl_iter_replace(iter, &e));

	int_tbl_iter_free(iter);

	/* Verify replacement */
	result = int_tbl_get(ht, &e.key);
	ASSERT(result != NULL);
	ASSERT(result->value == 9999);

	int_tbl_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Read/write iterators
 *
 ******************************************************************************/

TEST(rw_iterator_empty_table)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	iter = int_tbl_iter_new(ht, SHT_ITER_RW);
	ASSERT(iter != NULL);
	ASSERT(int_tbl_iter_next(iter) == NULL);
	int_tbl_iter_free(iter);

	int_tbl_free(ht);
}

TEST(rw_iterator_exclusive)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	iter = int_tbl_iter_new(ht, SHT_ITER_RW);
	ASSERT(iter != NULL);

	/* Try to create another rw iterator - should fail */
	struct int_tbl_iter *iter2 = int_tbl_iter_new(ht, SHT_ITER_RW);
	ASSERT(iter2 == NULL);
	ASSERT(int_tbl_get_err(ht) == SHT_ERR_ITER_LOCK);

	/* Try to create ro iterator - should also fail */
	struct int_tbl_iter *ro_iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(ro_iter == NULL);
	ASSERT(int_tbl_get_err(ht) == SHT_ERR_ITER_LOCK);

	int_tbl_iter_free(iter);
	int_tbl_free(ht);
}

TEST(ro_iterator_blocks_rw)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *ro_iter;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	ro_iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(ro_iter != NULL);

	/* Try to create rw iterator - should fail */
	struct int_tbl_iter *rw_iter = int_tbl_iter_new(ht, SHT_ITER_RW);
	ASSERT(rw_iter == NULL);
	ASSERT(int_tbl_get_err(ht) == SHT_ERR_ITER_LOCK);

	int_tbl_iter_free(ro_iter);
	int_tbl_free(ht);
}

TEST(rw_iterator_delete)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e;
	const struct int_entry *result;
	int i, count;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(int_tbl_add(ht, &e.key, &e) == 0);
	}

	iter = int_tbl_iter_new(ht, SHT_ITER_RW);
	ASSERT(iter != NULL);

	count = 0;
	while ((result = int_tbl_iter_next(iter)) != NULL) {
		if (result->key % 2 == 0) {
			ASSERT(int_tbl_iter_delete(iter));
		}
		count++;
	}
	ASSERT(count == 10);

	int_tbl_iter_free(iter);

	/* Verify even keys are gone */
	for (i = 0; i < 10; i++) {
		const struct int_entry *r = int_tbl_get(ht, &i);
		if (i % 2 == 0) {
			ASSERT(r == NULL);
		} else {
			ASSERT(r != NULL);
			ASSERT(r->value == i * 10);
		}
	}

	int_tbl_free(ht);
}

TEST(rw_iterator_replace)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e;
	const struct int_entry *result;
	int i;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(int_tbl_add(ht, &e.key, &e) == 0);
	}

	iter = int_tbl_iter_new(ht, SHT_ITER_RW);
	ASSERT(iter != NULL);

	while ((result = int_tbl_iter_next(iter)) != NULL) {
		e.key = result->key;
		e.value = result->key * 100;
		ASSERT(int_tbl_iter_replace(iter, &e));
	}

	int_tbl_iter_free(iter);

	/* Verify all values updated */
	for (i = 0; i < 10; i++) {
		const struct int_entry *r = int_tbl_get(ht, &i);
		ASSERT(r != NULL);
		ASSERT(r->value == i * 100);
	}

	int_tbl_free(ht);
}

TEST(iterator_delete_no_last)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	iter = int_tbl_iter_new(ht, SHT_ITER_RW);
	ASSERT(iter != NULL);

	/* Try to delete before calling NEXT */
	ASSERT(!int_tbl_iter_delete(iter));
	ASSERT(int_tbl_iter_err(iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(int_tbl_iter_msg(iter), "Iterator at beginning or end") == 0);

	/* Advance iterator */
	ASSERT(int_tbl_iter_next(iter) != NULL);
	ASSERT(int_tbl_iter_next(iter) == NULL);

	/* Try to delete after reaching end */
	ASSERT(!int_tbl_iter_delete(iter));
	ASSERT(int_tbl_iter_err(iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(int_tbl_iter_msg(iter), "Iterator at beginning or end") == 0);

	int_tbl_iter_free(iter);
	int_tbl_free(ht);
}

TEST(iterator_replace_no_last)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	iter = int_tbl_iter_new(ht, SHT_ITER_RW);
	ASSERT(iter != NULL);

	/* Try to replace before calling NEXT */
	e.value = 200;
	ASSERT(!int_tbl_iter_replace(iter, &e));
	ASSERT(int_tbl_iter_err(iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(int_tbl_iter_msg(iter), "Iterator at beginning or end") == 0);

	int_tbl_iter_free(iter);
	int_tbl_free(ht);
}

TEST(iterator_error_messages)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *ro_iter;
	struct int_tbl_iter *rw_iter;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	/* Test read-only iterator error messages */
	ro_iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(ro_iter != NULL);

	e.value = 200;
	ASSERT(!int_tbl_iter_replace(ro_iter, &e));
	ASSERT(int_tbl_iter_err(ro_iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(int_tbl_iter_msg(ro_iter), "Iterator at beginning or end") == 0);

	int_tbl_iter_free(ro_iter);

	/* Test read/write iterator error messages */
	rw_iter = int_tbl_iter_new(ht, SHT_ITER_RW);
	ASSERT(rw_iter != NULL);

	ASSERT(!int_tbl_iter_delete(rw_iter));
	ASSERT(int_tbl_iter_err(rw_iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(int_tbl_iter_msg(rw_iter), "Iterator at beginning or end") == 0);

	e.value = 300;
	ASSERT(!int_tbl_iter_replace(rw_iter, &e));
	ASSERT(int_tbl_iter_err(rw_iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(int_tbl_iter_msg(rw_iter), "Iterator at beginning or end") == 0);

	int_tbl_iter_free(rw_iter);
	int_tbl_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Edge cases and stress tests
 *
 ******************************************************************************/

TEST(delete_and_readd)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int i, key;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	/* Add, delete, and re-add entries multiple times */
	for (i = 0; i < 100; i++) {
		key = i % 10;
		e.key = key;
		e.value = i;

		if (i % 3 == 0 && int_tbl_get(ht, &key) != NULL) {
			ASSERT(int_tbl_delete(ht, &key));
		}

		int result = int_tbl_add(ht, &key, &e);
		ASSERT(result == 0 || result == 1);
	}

	int_tbl_free(ht);
}

TEST(wraparound_deletion)
{
	struct bad_ht *ht;
	struct int_entry e;
	int i;

	/* Use bad hash to force entries at end of table */
	ht = bad_new();
	ASSERT(ht != NULL);
	ASSERT(bad_init(ht, 8));

	/* Fill table to force wraparound */
	for (i = 0; i < 6; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(bad_add(ht, &e.key, &e) == 0);
	}

	/* Delete entries to test wraparound shifting */
	for (i = 0; i < 6; i += 2) {
		ASSERT(bad_delete(ht, &i));
	}

	/* Verify remaining entries */
	for (i = 0; i < 6; i++) {
		const struct int_entry *r = bad_get(ht, &i);
		if (i % 2 == 0) {
			ASSERT(r == NULL);
		} else {
			ASSERT(r != NULL);
			ASSERT(r->value == i * 10);
		}
	}

	bad_free(ht);
}

TEST(string_keys)
{
	struct str_ht *ht;
	struct str_entry e;
	const struct str_entry *result;
	const char *keys[] = {"foo", "bar", "baz", "qux"};
	int i;

	ht = str_new();
	ASSERT(ht != NULL);
	ASSERT(str_init(ht, 0));

	for (i = 0; i < 4; i++) {
		e.key = strdup(keys[i]);
		e.value = strdup("value");
		ASSERT(str_add(ht, keys[i], &e) == 0);
	}

	for (i = 0; i < 4; i++) {
		result = str_get(ht, keys[i]);
		ASSERT(result != NULL);
		ASSERT(strcmp(result->key, keys[i]) == 0);
	}

	str_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Abort conditions
 *
 ******************************************************************************/

TEST(abort_invalid_error_code)
{
	ASSERT_ABORTS(sht_msg(SHT_ERR_COUNT), "Invalid error code");
}

TEST(abort_ealign_not_power_of_2)
{
	ASSERT_ABORTS(sht_new_(raw_hashfn, raw_eqfn, NULL, sizeof(struct int_entry), 3, NULL),
		      "ealign not a power of 2");
}

TEST(abort_esize_ealign_incompatible)
{
	ASSERT_ABORTS(sht_new_(raw_hashfn, raw_eqfn, NULL, 10, 8, NULL),
		      "Incompatible values of esize and ealign");
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnonnull"
TEST(abort_null_hashfn)
{
	ASSERT_ABORTS(sht_new_(NULL, raw_eqfn, NULL, sizeof(struct int_entry),
			       _Alignof(struct int_entry), NULL),
		      "hashfn must not be NULL");
}

TEST(abort_null_eqfn)
{
	ASSERT_ABORTS(sht_new_(raw_hashfn, NULL, NULL, sizeof(struct int_entry),
			       _Alignof(struct int_entry), NULL),
		      "eqfn must not be NULL");
}
#pragma GCC diagnostic pop

TEST(abort_set_hash_ctx_after_init)
{
	struct ctx_hash_ht *ht;
	uint32_t ctx = 1;

	ht = ctx_hash_new();
	ASSERT(ht != NULL);
	ASSERT(ctx_hash_init(ht, 0));

	ASSERT_ABORTS(ctx_hash_set_hash_ctx(ht, &ctx), "already initialized");

	ctx_hash_free(ht);
}

TEST(abort_set_eq_ctx_after_init)
{
	struct ctx_eq_ht *ht;
	int ctx = 1;

	ht = ctx_eq_new();
	ASSERT(ht != NULL);
	ASSERT(ctx_eq_init(ht, 0));

	ASSERT_ABORTS(ctx_eq_set_eq_ctx(ht, &ctx), "already initialized");

	ctx_eq_free(ht);
}

TEST(abort_set_free_ctx_after_init)
{
	struct ctx_free_ht *ht;
	int ctx = 1;

	ht = ctx_free_new();
	ASSERT(ht != NULL);
	ASSERT(ctx_free_init(ht, 0));

	ASSERT_ABORTS(ctx_free_set_free_ctx(ht, &ctx), "already initialized");

	ctx_free_free(ht);
}

TEST(abort_set_lft_after_init)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	ASSERT_ABORTS(int_tbl_set_lft(ht, 50), "already initialized");

	int_tbl_free(ht);
}

TEST(abort_set_lft_invalid_low)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_set_lft(ht, 0), "Invalid load factor");

	free(ht);
}

TEST(abort_set_lft_invalid_high)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_set_lft(ht, 101), "Invalid load factor");

	free(ht);
}

TEST(abort_set_psl_thold_after_init)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	ASSERT_ABORTS(int_tbl_set_psl_limit(ht, 100), "already initialized");

	int_tbl_free(ht);
}

TEST(abort_set_psl_thold_invalid_low)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_set_psl_limit(ht, 0), "Invalid PSL threshold");

	free(ht);
}

TEST(abort_set_psl_thold_invalid_high)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_set_psl_limit(ht, 128), "Invalid PSL threshold");

	free(ht);
}

TEST(abort_init_twice)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	ASSERT_ABORTS(int_tbl_init(ht, 0), "already initialized");

	int_tbl_free(ht);
}

TEST(abort_size_not_initialized)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_size(ht), "not initialized");

	free(ht);
}

TEST(abort_empty_not_initialized)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_empty(ht), "not initialized");

	free(ht);
}

TEST(abort_get_not_initialized)
{
	struct int_tbl_ht *ht;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_get(ht, &key), "not initialized");

	free(ht);
}

TEST(abort_add_not_initialized)
{
	struct int_tbl_ht *ht;
	struct int_entry e = { .key = 42, .value = 100 };
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_add(ht, &key, &e), "not initialized");

	free(ht);
}

TEST(abort_set_not_initialized)
{
	struct int_tbl_ht *ht;
	struct int_entry e = { .key = 42, .value = 100 };
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_set(ht, &key, &e), "not initialized");

	free(ht);
}

TEST(abort_replace_not_initialized)
{
	struct int_tbl_ht *ht;
	struct int_entry e = { .key = 42, .value = 100 };
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_replace(ht, &key, &e), "not initialized");

	free(ht);
}

TEST(abort_swap_not_initialized)
{
	struct int_tbl_ht *ht;
	struct int_entry e = { .key = 42, .value = 100 };
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_swap(ht, &key, &e, &e), "not initialized");

	free(ht);
}

TEST(abort_pop_not_initialized)
{
	struct int_tbl_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_pop(ht, &key, &e), "not initialized");

	free(ht);
}

TEST(abort_delete_not_initialized)
{
	struct int_tbl_ht *ht;
	int key = 42;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_delete(ht, &key), "not initialized");

	free(ht);
}

TEST(abort_ro_iter_not_initialized)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_iter_new(ht, SHT_ITER_RO), "not initialized");

	free(ht);
}

TEST(abort_rw_iter_not_initialized)
{
	struct int_tbl_ht *ht;

	ht = int_tbl_new();
	ASSERT(ht != NULL);

	ASSERT_ABORTS(int_tbl_iter_new(ht, SHT_ITER_RW), "not initialized");

	free(ht);
}

TEST(abort_add_with_iterator)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e = { .key = 1, .value = 10 };
	struct int_entry e2 = { .key = 2, .value = 20 };
	int key1 = 1, key2 = 2;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));
	ASSERT(int_tbl_add(ht, &key1, &e) == 0);

	iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter != NULL);

	ASSERT_ABORTS(int_tbl_add(ht, &key2, &e2), "iterator");

	int_tbl_iter_free(iter);
	int_tbl_free(ht);
}

TEST(abort_set_with_iterator)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e = { .key = 1, .value = 10 };
	struct int_entry e2 = { .key = 2, .value = 20 };
	int key1 = 1, key2 = 2;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));
	ASSERT(int_tbl_add(ht, &key1, &e) == 0);

	iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter != NULL);

	ASSERT_ABORTS(int_tbl_set(ht, &key2, &e2), "iterator");

	int_tbl_iter_free(iter);
	int_tbl_free(ht);
}

TEST(abort_pop_with_iterator)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e = { .key = 1, .value = 10 };
	struct int_entry popped;
	int key = 1;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter != NULL);

	ASSERT_ABORTS(int_tbl_pop(ht, &key, &popped), "iterator");

	int_tbl_iter_free(iter);
	int_tbl_free(ht);
}

TEST(abort_delete_with_iterator)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e = { .key = 1, .value = 10 };
	int key = 1;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter != NULL);

	ASSERT_ABORTS(int_tbl_delete(ht, &key), "iterator");

	int_tbl_iter_free(iter);
	int_tbl_free(ht);
}

TEST(abort_free_with_iterator)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e = { .key = 1, .value = 10 };
	int key = 1;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));
	ASSERT(int_tbl_add(ht, &key, &e) == 0);

	iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter != NULL);

	ASSERT_ABORTS(int_tbl_free(ht), "iterator");

	int_tbl_iter_free(iter);
	int_tbl_free(ht);
}

TEST(abort_iter_delete_read_only)
{
	struct int_tbl_ht *ht;
	struct int_tbl_iter *iter;
	struct int_entry e;
	const struct int_entry *result;
	int i;

	ht = int_tbl_new();
	ASSERT(ht != NULL);
	ASSERT(int_tbl_init(ht, 0));

	/* Add some entries */
	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(int_tbl_add(ht, &e.key, &e) == 0);
	}

	/* Create read-only iterator */
	iter = int_tbl_iter_new(ht, SHT_ITER_RO);
	ASSERT(iter != NULL);

	/* Get first entry */
	result = int_tbl_iter_next(iter);
	ASSERT(result != NULL);

	/* Try to delete via read-only iterator - should abort */
	ASSERT_ABORTS(int_tbl_iter_delete(iter), "read-only");

	int_tbl_iter_free(iter);
	int_tbl_free(ht);
}

/*******************************************************************************
 *
 *	Main test runner
 *
 ******************************************************************************/

int main(void)
{
	printf("=== Hash Table Type-Safe API Comprehensive Test Suite ===\n\n");

	/* Basic creation and initialization */
	RUN_TEST(create_without_err_pointer);
	RUN_TEST(create_and_free);
	RUN_TEST(create_with_capacity);
	RUN_TEST(entry_size_too_large);
	RUN_TEST(entry_size_maximum);
	RUN_TEST(capacity_too_large);
	RUN_TEST(unusual_alignment);

	/* Table state query operations */
	RUN_TEST(size_empty_table);
	RUN_TEST(size_with_entries);
	RUN_TEST(size_after_delete);
	RUN_TEST(empty_initial_table);
	RUN_TEST(empty_with_entries);
	RUN_TEST(empty_after_clear);

	/* Context and configuration */
	RUN_TEST(hash_context);
	RUN_TEST(eq_context);
	RUN_TEST(free_context);
	RUN_TEST(load_factor_threshold);
	RUN_TEST(psl_threshold);

	/* Add operations */
	RUN_TEST(add_new_entry);
	RUN_TEST(add_duplicate_entry);
	RUN_TEST(add_multiple_entries);

	/* Set operations */
	RUN_TEST(set_new_entry);
	RUN_TEST(set_replace_entry);
	RUN_TEST(set_with_freefn);

	/* Get operations */
	RUN_TEST(get_existing_entry);
	RUN_TEST(get_nonexistent_entry);

	/* Replace operations */
	RUN_TEST(replace_existing_entry);
	RUN_TEST(replace_nonexistent_entry);

	/* Swap operations */
	RUN_TEST(swap_existing_entry);
	RUN_TEST(swap_nonexistent_entry);
	RUN_TEST(swap_separate_buffers);

	/* Delete operations */
	RUN_TEST(delete_existing_entry);
	RUN_TEST(delete_nonexistent_entry);
	RUN_TEST(pop_existing_entry);
	RUN_TEST(pop_nonexistent_entry);

	/* Table growth and collision handling */
	RUN_TEST(table_growth);
	RUN_TEST(collision_handling);
	RUN_TEST(excessive_collisions);
	RUN_TEST(excessive_collisions_psl_10);
	RUN_TEST(excessive_collisions_psl_50);
	RUN_TEST(excessive_collisions_psl_1);
	RUN_TEST(psl_tracking_after_delete);

	/* Read-only iterators */
	RUN_TEST(ro_iterator_empty_table);
	RUN_TEST(ro_iterator_all_entries);
	RUN_TEST(multiple_ro_iterators);
	RUN_TEST(ro_iterator_max_count);
	RUN_TEST(ro_iterator_replace);

	/* Read/write iterators */
	RUN_TEST(rw_iterator_empty_table);
	RUN_TEST(rw_iterator_exclusive);
	RUN_TEST(ro_iterator_blocks_rw);
	RUN_TEST(rw_iterator_delete);
	RUN_TEST(rw_iterator_replace);
	RUN_TEST(iterator_delete_no_last);
	RUN_TEST(iterator_replace_no_last);
	RUN_TEST(iterator_error_messages);

	/* Edge cases and stress tests */
	RUN_TEST(delete_and_readd);
	RUN_TEST(wraparound_deletion);
	RUN_TEST(string_keys);

	/* Abort conditions */
	RUN_TEST(abort_invalid_error_code);
	RUN_TEST(abort_ealign_not_power_of_2);
	RUN_TEST(abort_esize_ealign_incompatible);
	RUN_TEST(abort_null_hashfn);
	RUN_TEST(abort_null_eqfn);
	RUN_TEST(abort_set_hash_ctx_after_init);
	RUN_TEST(abort_set_eq_ctx_after_init);
	RUN_TEST(abort_set_free_ctx_after_init);
	RUN_TEST(abort_set_lft_after_init);
	RUN_TEST(abort_set_lft_invalid_low);
	RUN_TEST(abort_set_lft_invalid_high);
	RUN_TEST(abort_set_psl_thold_after_init);
	RUN_TEST(abort_set_psl_thold_invalid_low);
	RUN_TEST(abort_set_psl_thold_invalid_high);
	RUN_TEST(abort_init_twice);
	RUN_TEST(abort_size_not_initialized);
	RUN_TEST(abort_empty_not_initialized);
	RUN_TEST(abort_get_not_initialized);
	RUN_TEST(abort_add_not_initialized);
	RUN_TEST(abort_set_not_initialized);
	RUN_TEST(abort_replace_not_initialized);
	RUN_TEST(abort_swap_not_initialized);
	RUN_TEST(abort_pop_not_initialized);
	RUN_TEST(abort_delete_not_initialized);
	RUN_TEST(abort_ro_iter_not_initialized);
	RUN_TEST(abort_rw_iter_not_initialized);
	RUN_TEST(abort_add_with_iterator);
	RUN_TEST(abort_set_with_iterator);
	RUN_TEST(abort_pop_with_iterator);
	RUN_TEST(abort_delete_with_iterator);
	RUN_TEST(abort_free_with_iterator);
	RUN_TEST(abort_iter_delete_read_only);

	/* Summary */
	printf("\n=== Test Summary ===\n");
	printf("Tests run:    %u\n", tests_run);
	printf("Tests passed: %u\n", tests_passed);
	printf("Tests failed: %u\n", tests_failed);

	if (tests_failed == 0) {
		printf("\nAll tests PASSED!\n");
		return 0;
	} else {
		printf("\nSome tests FAILED!\n");
		return 1;
	}
}
