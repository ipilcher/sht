// SPDX-License-Identifier: GPL-3.0-or-later

/*
 *
 * 	SHT - hash table with "Robin Hood" probing
 *
 * 	Hash table comprehensive test suite
 *
 *	Copyright 2025 Ian Pilcher <arequipeno@gmail.com>
 *
 *	NOTE: This test suite was generated by Claude Code, Anthropic's
 *	      official CLI for Claude AI.
 *
 */

#include "../src/sht.h"

#include <assert.h>
#include <inttypes.h>
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <xxhash.h>

/*******************************************************************************
 *
 *	Test framework
 *
 ******************************************************************************/

static unsigned int tests_run = 0;
static unsigned int tests_passed = 0;
static unsigned int tests_failed = 0;

#define TEST(name) \
	static void test_##name(void); \
	static void run_##name(void) { \
		printf("Running test: %s ... ", #name); \
		fflush(stdout); \
		tests_run++; \
		test_##name(); \
		tests_passed++; \
		printf("PASSED\n"); \
	} \
	static void test_##name(void)

#define ASSERT(cond) \
	do { \
		if (!(cond)) { \
			printf("FAILED\n  %s:%d: assertion failed: %s\n", \
			       __FILE__, __LINE__, #cond); \
			tests_failed++; \
			return; \
		} \
	} while (0)

#define RUN_TEST(name) run_##name()

/*******************************************************************************
 *
 *	Abort condition testing infrastructure
 *
 ******************************************************************************/

static jmp_buf abort_jmp_buf;
static const char *abort_msg_received = NULL;
static void (*saved_abort_print)(const char *) = NULL;

static void test_abort_handler(const char *msg)
{
	abort_msg_received = msg;
	longjmp(abort_jmp_buf, 1);
}

static void setup_abort_test(void)
{
	saved_abort_print = sht_abort_print;
	sht_abort_print = test_abort_handler;
	abort_msg_received = NULL;
}

static void teardown_abort_test(void)
{
	sht_abort_print = saved_abort_print;
	abort_msg_received = NULL;
}

#define ASSERT_ABORTS(code, expected_msg_substr) \
	do { \
		setup_abort_test(); \
		if (setjmp(abort_jmp_buf) == 0) { \
			code; \
			teardown_abort_test(); \
			printf("FAILED\n  %s:%d: expected abort but didn't happen\n", \
			       __FILE__, __LINE__); \
			tests_failed++; \
			return; \
		} \
		ASSERT(abort_msg_received != NULL); \
		ASSERT(strstr(abort_msg_received, expected_msg_substr) != NULL); \
		teardown_abort_test(); \
	} while (0)

/*******************************************************************************
 *
 *	Test entry types
 *
 ******************************************************************************/

/* Simple string key/value entry */
struct str_entry {
	char *key;
	char *value;
};

/* Integer key/value entry */
struct int_entry {
	int key;
	int value;
};

/* Large entry (to test size limits) */
struct large_entry {
	char data[16384];  /* Maximum size */
};

/* Over-sized entry (to test error handling) */
struct oversized_entry {
	char data[16385];  /* Too large */
};

/* Entry with unusual alignment */
struct __attribute__((aligned(64))) aligned_entry {
	int value;
};

/*******************************************************************************
 *
 *	Hash and comparison functions
 *
 ******************************************************************************/

static uint32_t str_hashfn(const void *restrict key, void *restrict ctx)
{
	(void)ctx;
	return XXH3_64bits(key, strlen(key));
}

static _Bool str_eqfn(const void *restrict key, const void *restrict entry,
		      void *restrict ctx)
{
	const struct str_entry *e = entry;
	(void)ctx;
	return strcmp(key, e->key) == 0;
}

static void str_freefn(const void *restrict entry, void *restrict ctx)
{
	const struct str_entry *e = entry;
	(void)ctx;
	free(e->key);
	free(e->value);
}

static uint32_t int_hashfn(const void *restrict key, void *restrict ctx)
{
	const int *k = key;
	(void)ctx;
	return XXH3_64bits(k, sizeof(*k));
}

static _Bool int_eqfn(const void *restrict key, const void *restrict entry,
		      void *restrict ctx)
{
	const int *k = key;
	const struct int_entry *e = entry;
	(void)ctx;
	return *k == e->key;
}

/* Pathological hash function that always returns 0 (tests collision handling) */
static uint32_t bad_hashfn(const void *restrict key, void *restrict ctx)
{
	(void)key;
	(void)ctx;
	return 0;
}

/* Hash function with context */
static uint32_t ctx_hashfn(const void *restrict key, void *restrict ctx)
{
	const int *k = key;
	const int *seed = ctx;
	return XXH32(k, sizeof(*k), *seed);
}

/* Equality function with context */
static int eq_context_used = 0;
static _Bool ctx_eqfn(const void *restrict key, const void *restrict entry,
		      void *restrict ctx)
{
	const int *k = key;
	const struct int_entry *e = entry;
	if (ctx != NULL)
		eq_context_used = 1;
	return *k == e->key;
}

/* Free function with context */
static int free_context_used = 0;
static void ctx_freefn(const void *restrict entry, void *restrict ctx)
{
	(void)entry;
	if (ctx != NULL)
		free_context_used = 1;
}

/*******************************************************************************
 *
 *	Tests: Basic table creation and initialization
 *
 ******************************************************************************/

TEST(create_and_free)
{
	struct sht_ht *ht;
	enum sht_err err;

	ht = SHT_NEW(str_hashfn, str_eqfn, struct str_entry, &err);
	ASSERT(ht != NULL);
	ASSERT(err == SHT_ERR_OK);
	ASSERT(sht_init(ht, 0));
	sht_free(ht);
}

TEST(create_without_err_pointer)
{
	struct sht_ht *ht;

	ht = SHT_NEW(str_hashfn, str_eqfn, struct str_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));
	sht_free(ht);
}

TEST(create_with_capacity)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 100));
	sht_free(ht);
}

TEST(entry_size_too_large)
{
	struct sht_ht *ht;
	enum sht_err err = SHT_ERR_OK;

	/* Call sht_new_() directly to test runtime validation.
	   (SHT_NEW() has compile-time validation that would fail here.) */
	ht = sht_new_(int_hashfn, int_eqfn, sizeof(struct oversized_entry),
		      _Alignof(struct oversized_entry), &err);
	ASSERT(ht == NULL);
	ASSERT(err == SHT_ERR_BAD_ESIZE);
	ASSERT(strcmp(sht_msg(err), "Entry size too large (> 16KiB)") == 0);
}

TEST(entry_size_maximum)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct large_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));
	sht_free(ht);
}

TEST(capacity_too_large)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(!sht_init(ht, UINT32_C(1) << 25));  /* > 16,777,216 */
	ASSERT(sht_get_err(ht) == SHT_ERR_TOOBIG);
	ASSERT(strcmp(sht_get_msg(ht), "Requested table size too large") == 0);
	sht_free(ht);
}

TEST(unusual_alignment)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct aligned_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));
	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Table state query operations
 *
 ******************************************************************************/

TEST(size_empty_table)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT(sht_size(ht) == 0);

	sht_free(ht);
}

TEST(size_with_entries)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	/* Add entries and verify size */
	for (i = 0; i < 100; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
		ASSERT(sht_size(ht) == (uint32_t)(i + 1));
	}

	sht_free(ht);
}

TEST(size_after_delete)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	/* Add entries */
	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
	}
	ASSERT(sht_size(ht) == 10);

	/* Delete entries and verify size */
	for (i = 0; i < 5; i++) {
		ASSERT(sht_delete(ht, &i));
		ASSERT(sht_size(ht) == (uint32_t)(10 - i - 1));
	}
	ASSERT(sht_size(ht) == 5);

	sht_free(ht);
}

TEST(empty_initial_table)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT(sht_empty(ht) == 1);

	sht_free(ht);
}

TEST(empty_with_entries)
{
	struct sht_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT(sht_empty(ht) == 1);

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);

	ASSERT(sht_empty(ht) == 0);

	sht_free(ht);
}

TEST(empty_after_clear)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	/* Add entries */
	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
	}
	ASSERT(sht_empty(ht) == 0);

	/* Delete all entries */
	for (i = 0; i < 10; i++) {
		ASSERT(sht_delete(ht, &i));
	}
	ASSERT(sht_empty(ht) == 1);

	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Context and configuration functions
 *
 ******************************************************************************/

TEST(hash_context)
{
	struct sht_ht *ht;
	int seed = 42;

	ht = SHT_NEW(ctx_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	sht_set_hash_ctx(ht, &seed);
	ASSERT(sht_init(ht, 0));

	/* Just verify it doesn't crash - hard to test hash context without
	   examining internal state */
	struct int_entry e = { .key = 1, .value = 100 };
	int key = 1;
	ASSERT(sht_add(ht, &key, &e) == 0);

	sht_free(ht);
}

TEST(eq_context)
{
	struct sht_ht *ht;
	int ctx = 1;

	eq_context_used = 0;
	ht = SHT_NEW(int_hashfn, ctx_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	sht_set_eq_ctx(ht, &ctx);
	ASSERT(sht_init(ht, 0));

	struct int_entry e = { .key = 1, .value = 100 };
	int key = 1;
	ASSERT(sht_add(ht, &key, &e) == 0);
	ASSERT(sht_get(ht, &key) != NULL);
	ASSERT(eq_context_used == 1);

	sht_free(ht);
}

TEST(free_context)
{
	struct sht_ht *ht;
	int ctx = 1;

	free_context_used = 0;
	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	sht_set_freefn(ht, ctx_freefn, &ctx);
	ASSERT(sht_init(ht, 0));

	struct int_entry e = { .key = 1, .value = 100 };
	int key = 1;
	ASSERT(sht_add(ht, &key, &e) == 0);

	sht_free(ht);
	ASSERT(free_context_used == 1);
}

TEST(load_factor_threshold)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	sht_set_lft(ht, 50);  /* 50% load factor */
	ASSERT(sht_init(ht, 0));
	sht_free(ht);
}

TEST(psl_threshold)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	sht_set_psl_limit(ht, 100);  /* PSL threshold of 100 */
	ASSERT(sht_init(ht, 0));
	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Add operations
 *
 ******************************************************************************/

TEST(add_new_entry)
{
	struct sht_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);  /* New entry */

	sht_free(ht);
}

TEST(add_duplicate_entry)
{
	struct sht_ht *ht;
	struct int_entry e1, e2;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e1.key = 42;
	e1.value = 100;
	ASSERT(sht_add(ht, &key, &e1) == 0);  /* New entry */

	e2.key = 42;
	e2.value = 200;
	ASSERT(sht_add(ht, &key, &e2) == 1);  /* Duplicate - not added */

	const struct int_entry *result = sht_get(ht, &key);
	ASSERT(result != NULL);
	ASSERT(result->value == 100);  /* Original value unchanged */

	sht_free(ht);
}

TEST(add_multiple_entries)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	for (i = 0; i < 100; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
	}

	/* Verify all entries */
	for (i = 0; i < 100; i++) {
		const struct int_entry *result = sht_get(ht, &i);
		ASSERT(result != NULL);
		ASSERT(result->key == i);
		ASSERT(result->value == i * 10);
	}

	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Set operations
 *
 ******************************************************************************/

TEST(set_new_entry)
{
	struct sht_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_set(ht, &key, &e) == 0);  /* New entry */

	sht_free(ht);
}

TEST(set_replace_entry)
{
	struct sht_ht *ht;
	struct int_entry e1, e2;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e1.key = 42;
	e1.value = 100;
	ASSERT(sht_set(ht, &key, &e1) == 0);  /* New entry */

	e2.key = 42;
	e2.value = 200;
	ASSERT(sht_set(ht, &key, &e2) == 1);  /* Replace */

	const struct int_entry *result = sht_get(ht, &key);
	ASSERT(result != NULL);
	ASSERT(result->value == 200);  /* Updated value */

	sht_free(ht);
}

TEST(set_with_freefn)
{
	struct sht_ht *ht;
	struct str_entry e1, e2;
	const char *key = "test";

	ht = SHT_NEW(str_hashfn, str_eqfn, struct str_entry);
	ASSERT(ht != NULL);
	sht_set_freefn(ht, str_freefn, NULL);
	ASSERT(sht_init(ht, 0));

	e1.key = strdup("test");
	e1.value = strdup("value1");
	ASSERT(sht_set(ht, key, &e1) == 0);

	e2.key = strdup("test");
	e2.value = strdup("value2");
	ASSERT(sht_set(ht, key, &e2) == 1);  /* Should free e1's strings */

	sht_free(ht);  /* Should free e2's strings */
}

/*******************************************************************************
 *
 *	Tests: Get operations
 *
 ******************************************************************************/

TEST(get_existing_entry)
{
	struct sht_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);

	const struct int_entry *result = sht_get(ht, &key);
	ASSERT(result != NULL);
	ASSERT(result->key == 42);
	ASSERT(result->value == 100);

	sht_free(ht);
}

TEST(get_nonexistent_entry)
{
	struct sht_ht *ht;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	const struct int_entry *result = sht_get(ht, &key);
	ASSERT(result == NULL);

	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Replace operations
 *
 ******************************************************************************/

TEST(replace_existing_entry)
{
	struct sht_ht *ht;
	struct int_entry e1, e2;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e1.key = 42;
	e1.value = 100;
	ASSERT(sht_add(ht, &key, &e1) == 0);

	e2.key = 42;
	e2.value = 200;
	ASSERT(sht_replace(ht, &key, &e2));

	const struct int_entry *result = sht_get(ht, &key);
	ASSERT(result != NULL);
	ASSERT(result->value == 200);

	sht_free(ht);
}

TEST(replace_nonexistent_entry)
{
	struct sht_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(!sht_replace(ht, &key, &e));

	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Swap operations
 *
 ******************************************************************************/

TEST(swap_existing_entry)
{
	struct sht_ht *ht;
	struct int_entry e1, e2;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e1.key = 42;
	e1.value = 100;
	ASSERT(sht_add(ht, &key, &e1) == 0);

	e2.key = 42;
	e2.value = 200;
	ASSERT(sht_swap(ht, &key, &e2, &e2));
	ASSERT(e2.key == 42);
	ASSERT(e2.value == 100);  /* Old value */

	const struct int_entry *result = sht_get(ht, &key);
	ASSERT(result != NULL);
	ASSERT(result->value == 200);

	sht_free(ht);
}

TEST(swap_nonexistent_entry)
{
	struct sht_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(!sht_swap(ht, &key, &e, &e));

	sht_free(ht);
}

TEST(swap_separate_buffers)
{
	struct sht_ht *ht;
	struct int_entry e1, e2, old;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e1.key = 42;
	e1.value = 100;
	ASSERT(sht_add(ht, &key, &e1) == 0);

	e2.key = 42;
	e2.value = 200;
	ASSERT(sht_swap(ht, &key, &e2, &old));
	ASSERT(old.value == 100);
	ASSERT(e2.value == 200);  /* Unchanged */

	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Delete operations
 *
 ******************************************************************************/

TEST(delete_existing_entry)
{
	struct sht_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);
	ASSERT(sht_delete(ht, &key));
	ASSERT(sht_get(ht, &key) == NULL);

	sht_free(ht);
}

TEST(delete_nonexistent_entry)
{
	struct sht_ht *ht;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT(!sht_delete(ht, &key));

	sht_free(ht);
}

TEST(pop_existing_entry)
{
	struct sht_ht *ht;
	struct int_entry e, popped;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);
	ASSERT(sht_pop(ht, &key, &popped));
	ASSERT(popped.key == 42);
	ASSERT(popped.value == 100);
	ASSERT(sht_get(ht, &key) == NULL);

	sht_free(ht);
}

TEST(pop_nonexistent_entry)
{
	struct sht_ht *ht;
	struct int_entry popped;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT(!sht_pop(ht, &key, &popped));

	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Table growth and rehashing
 *
 ******************************************************************************/

TEST(table_growth)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 2));  /* Very small initial size */

	/* Add enough entries to force multiple rehashes */
	for (i = 0; i < 1000; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
	}

	/* Verify all entries survived rehashing */
	for (i = 0; i < 1000; i++) {
		const struct int_entry *result = sht_get(ht, &i);
		ASSERT(result != NULL);
		ASSERT(result->key == i);
		ASSERT(result->value == i * 10);
	}

	sht_free(ht);
}

TEST(collision_handling)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;

	/* Use pathological hash function to force collisions */
	ht = SHT_NEW(bad_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	/* Add entries that will all hash to the same value */
	for (i = 0; i < 50; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
	}

	/* Verify all entries can be retrieved */
	for (i = 0; i < 50; i++) {
		const struct int_entry *result = sht_get(ht, &i);
		ASSERT(result != NULL);
		ASSERT(result->key == i);
		ASSERT(result->value == i * 10);
	}

	sht_free(ht);
}

TEST(excessive_collisions)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;
	int result;

	/* Use pathological hash function and small table */
	ht = SHT_NEW(bad_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	sht_set_lft(ht, 95);  /* High load factor to delay growth */
	ASSERT(sht_init(ht, 128));

	/* Add entries until we exceed max PSL (127) - this MUST happen
	   because bad_hashfn forces all entries to the same bucket */
	for (i = 0; i < 200; i++) {
		e.key = i;
		e.value = i * 10;
		result = sht_add(ht, &e.key, &e);
		if (result == -1) {
			ASSERT(sht_get_err(ht) == SHT_ERR_BAD_HASH);
			sht_free(ht);
			return;
		}
	}

	/* Should never get here - bad_hashfn forces PSL limit */
	ASSERT(0 && "Should have hit SHT_ERR_BAD_HASH");
	sht_free(ht);
}

TEST(excessive_collisions_psl_10)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;
	int result;

	/* Use pathological hash function with low PSL threshold */
	ht = SHT_NEW(bad_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	sht_set_lft(ht, 95);  /* High load factor to delay growth */
	sht_set_psl_limit(ht, 10);  /* Low PSL threshold */
	ASSERT(sht_init(ht, 32));

	/* Add entries until we hit the PSL limit - this MUST happen
	   because bad_hashfn forces all entries to the same bucket */
	for (i = 0; i < 50; i++) {
		e.key = i;
		e.value = i * 10;
		result = sht_add(ht, &e.key, &e);
		if (result == -1) {
			ASSERT(sht_get_err(ht) == SHT_ERR_BAD_HASH);
			sht_free(ht);
			return;
		}
	}

	/* Should never get here - bad_hashfn forces PSL limit */
	ASSERT(0 && "Should have hit SHT_ERR_BAD_HASH");
	sht_free(ht);
}

TEST(excessive_collisions_psl_50)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;
	int result;

	/* Use pathological hash function with medium PSL threshold */
	ht = SHT_NEW(bad_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	sht_set_lft(ht, 95);  /* High load factor to delay growth */
	sht_set_psl_limit(ht, 50);  /* Medium PSL threshold */
	ASSERT(sht_init(ht, 64));

	/* Add entries until we hit the PSL limit - this MUST happen
	   because bad_hashfn forces all entries to the same bucket */
	for (i = 0; i < 100; i++) {
		e.key = i;
		e.value = i * 10;
		result = sht_add(ht, &e.key, &e);
		if (result == -1) {
			ASSERT(sht_get_err(ht) == SHT_ERR_BAD_HASH);
			sht_free(ht);
			return;
		}
	}

	/* Should never get here - bad_hashfn forces PSL limit */
	ASSERT(0 && "Should have hit SHT_ERR_BAD_HASH");
	sht_free(ht);
}

TEST(excessive_collisions_psl_1)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;
	int result;

	/* Use pathological hash function with minimal PSL threshold */
	ht = SHT_NEW(bad_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	sht_set_lft(ht, 95);  /* High load factor to delay growth */
	sht_set_psl_limit(ht, 1);  /* Minimal PSL threshold */
	ASSERT(sht_init(ht, 16));

	/* Add entries until we hit the PSL limit - this MUST happen
	   because bad_hashfn forces all entries to the same bucket */
	for (i = 0; i < 20; i++) {
		e.key = i;
		e.value = i * 10;
		result = sht_add(ht, &e.key, &e);
		if (result == -1) {
			ASSERT(sht_get_err(ht) == SHT_ERR_BAD_HASH);
			sht_free(ht);
			return;
		}
	}

	/* Should never get here - bad_hashfn forces PSL limit */
	ASSERT(0 && "Should have hit SHT_ERR_BAD_HASH");
	sht_free(ht);
}

TEST(psl_tracking_after_delete)
{
	struct sht_ht *ht;
	struct int_entry e;
	int keys[20];
	int i;
	int result;

	/* Use pathological hash with very low PSL threshold */
	ht = SHT_NEW(bad_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	sht_set_lft(ht, 95);  /* High load factor to prevent growth */
	sht_set_psl_limit(ht, 3);  /* Very low PSL threshold */
	ASSERT(sht_init(ht, 16));

	/* Add entries to create a chain up to PSL threshold */
	for (i = 0; i < 10; i++) {
		keys[i] = i;
		e.key = i;
		e.value = i * 10;
		result = sht_add(ht, &keys[i], &e);
		if (result == -1) {
			ASSERT(sht_get_err(ht) == SHT_ERR_BAD_HASH);
			break;
		}
	}

	/* If we successfully added entries, try deleting and re-adding
	   to test psl_maxxed tracking after deletions */
	if (i > 0) {
		/* Delete the last entry added */
		sht_delete(ht, &keys[i - 1]);

		/* Try to add more entries - should still respect PSL limit */
		for (; i < 20; i++) {
			keys[i] = i;
			e.key = i;
			e.value = i * 10;
			result = sht_add(ht, &keys[i], &e);
			if (result == -1) {
				ASSERT(sht_get_err(ht) == SHT_ERR_BAD_HASH);
				break;
			}
		}
	}

	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Read-only iterators
 *
 ******************************************************************************/

TEST(ro_iterator_empty_table)
{
	struct sht_ht *ht;
	struct sht_ro_iter *iter;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	iter = sht_ro_iter(ht);
	ASSERT(iter != NULL);
	ASSERT(SHT_ITER_NEXT(iter) == NULL);
	SHT_ITER_FREE(iter);

	sht_free(ht);
}

TEST(ro_iterator_all_entries)
{
	struct sht_ht *ht;
	struct sht_ro_iter *iter;
	struct int_entry e;
	const struct int_entry *result;
	int i, count;
	int seen[100] = {0};

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	for (i = 0; i < 100; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
	}

	iter = sht_ro_iter(ht);
	ASSERT(iter != NULL);

	count = 0;
	while ((result = SHT_ITER_NEXT(iter)) != NULL) {
		ASSERT(result->key >= 0 && result->key < 100);
		ASSERT(result->value == result->key * 10);
		ASSERT(seen[result->key] == 0);
		seen[result->key] = 1;
		count++;
	}
	ASSERT(count == 100);

	SHT_ITER_FREE(iter);
	sht_free(ht);
}

TEST(multiple_ro_iterators)
{
	struct sht_ht *ht;
	struct sht_ro_iter *iter1, *iter2;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);

	iter1 = sht_ro_iter(ht);
	ASSERT(iter1 != NULL);

	iter2 = sht_ro_iter(ht);
	ASSERT(iter2 != NULL);

	SHT_ITER_FREE(iter1);
	SHT_ITER_FREE(iter2);

	sht_free(ht);
}

TEST(ro_iterator_max_count)
{
	struct sht_ht *ht;
	struct sht_ro_iter *iters[32767];  /* SHT_MAX_ITERS */
	struct int_entry e;
	int i, key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);

	/* Create maximum number of iterators */
	for (i = 0; i < 32767; i++) {
		iters[i] = sht_ro_iter(ht);
		ASSERT(iters[i] != NULL);
	}

	/* Try to create one more - should fail */
	struct sht_ro_iter *extra = sht_ro_iter(ht);
	ASSERT(extra == NULL);
	ASSERT(sht_get_err(ht) == SHT_ERR_ITER_COUNT);

	/* Free all iterators */
	for (i = 0; i < 32767; i++) {
		SHT_ITER_FREE(iters[i]);
	}

	sht_free(ht);
}

TEST(ro_iterator_replace)
{
	struct sht_ht *ht;
	struct sht_ro_iter *iter;
	struct int_entry e;
	const struct int_entry *result;
	int i;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
	}

	iter = sht_ro_iter(ht);
	ASSERT(iter != NULL);

	/* Get first entry and replace it */
	result = SHT_ITER_NEXT(iter);
	ASSERT(result != NULL);

	e.key = result->key;
	e.value = 9999;
	ASSERT(SHT_ITER_REPLACE(iter, &e));

	SHT_ITER_FREE(iter);

	/* Verify replacement */
	result = sht_get(ht, &e.key);
	ASSERT(result != NULL);
	ASSERT(result->value == 9999);

	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Read/write iterators
 *
 ******************************************************************************/

TEST(rw_iterator_empty_table)
{
	struct sht_ht *ht;
	struct sht_rw_iter *iter;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	iter = sht_rw_iter(ht);
	ASSERT(iter != NULL);
	ASSERT(SHT_ITER_NEXT(iter) == NULL);
	SHT_ITER_FREE(iter);

	sht_free(ht);
}

TEST(rw_iterator_exclusive)
{
	struct sht_ht *ht;
	struct sht_rw_iter *iter;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);

	iter = sht_rw_iter(ht);
	ASSERT(iter != NULL);

	/* Try to create another rw iterator - should fail */
	struct sht_rw_iter *iter2 = sht_rw_iter(ht);
	ASSERT(iter2 == NULL);
	ASSERT(sht_get_err(ht) == SHT_ERR_ITER_LOCK);

	/* Try to create ro iterator - should also fail */
	struct sht_ro_iter *ro_iter = sht_ro_iter(ht);
	ASSERT(ro_iter == NULL);
	ASSERT(sht_get_err(ht) == SHT_ERR_ITER_LOCK);

	SHT_ITER_FREE(iter);
	sht_free(ht);
}

TEST(ro_iterator_blocks_rw)
{
	struct sht_ht *ht;
	struct sht_ro_iter *ro_iter;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);

	ro_iter = sht_ro_iter(ht);
	ASSERT(ro_iter != NULL);

	/* Try to create rw iterator - should fail */
	struct sht_rw_iter *rw_iter = sht_rw_iter(ht);
	ASSERT(rw_iter == NULL);
	ASSERT(sht_get_err(ht) == SHT_ERR_ITER_LOCK);

	SHT_ITER_FREE(ro_iter);
	sht_free(ht);
}

TEST(rw_iterator_delete)
{
	struct sht_ht *ht;
	struct sht_rw_iter *iter;
	struct int_entry e;
	struct int_entry *result;
	int i, count;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
	}

	iter = sht_rw_iter(ht);
	ASSERT(iter != NULL);

	count = 0;
	while ((result = SHT_ITER_NEXT(iter)) != NULL) {
		if (result->key % 2 == 0) {
			ASSERT(sht_iter_delete(iter));
		}
		count++;
	}
	ASSERT(count == 10);

	SHT_ITER_FREE(iter);

	/* Verify even keys are gone */
	for (i = 0; i < 10; i++) {
		const struct int_entry *r = sht_get(ht, &i);
		if (i % 2 == 0) {
			ASSERT(r == NULL);
		} else {
			ASSERT(r != NULL);
			ASSERT(r->value == i * 10);
		}
	}

	sht_free(ht);
}

TEST(rw_iterator_replace)
{
	struct sht_ht *ht;
	struct sht_rw_iter *iter;
	struct int_entry e;
	struct int_entry *result;
	int i;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	for (i = 0; i < 10; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
	}

	iter = sht_rw_iter(ht);
	ASSERT(iter != NULL);

	while ((result = SHT_ITER_NEXT(iter)) != NULL) {
		e.key = result->key;
		e.value = result->key * 100;
		ASSERT(SHT_ITER_REPLACE(iter, &e));
	}

	SHT_ITER_FREE(iter);

	/* Verify all values updated */
	for (i = 0; i < 10; i++) {
		const struct int_entry *r = sht_get(ht, &i);
		ASSERT(r != NULL);
		ASSERT(r->value == i * 100);
	}

	sht_free(ht);
}

TEST(iterator_delete_no_last)
{
	struct sht_ht *ht;
	struct sht_rw_iter *iter;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);

	iter = sht_rw_iter(ht);
	ASSERT(iter != NULL);

	/* Try to delete before calling NEXT */
	ASSERT(!sht_iter_delete(iter));
	ASSERT(SHT_ITER_ERR(iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(SHT_ITER_MSG(iter), "Iterator at beginning or end") == 0);

	/* Advance iterator */
	ASSERT(SHT_ITER_NEXT(iter) != NULL);
	ASSERT(SHT_ITER_NEXT(iter) == NULL);

	/* Try to delete after reaching end */
	ASSERT(!sht_iter_delete(iter));
	ASSERT(SHT_ITER_ERR(iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(SHT_ITER_MSG(iter), "Iterator at beginning or end") == 0);

	SHT_ITER_FREE(iter);
	sht_free(ht);
}

TEST(iterator_replace_no_last)
{
	struct sht_ht *ht;
	struct sht_rw_iter *iter;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);

	iter = sht_rw_iter(ht);
	ASSERT(iter != NULL);

	/* Try to replace before calling NEXT */
	e.value = 200;
	ASSERT(!SHT_ITER_REPLACE(iter, &e));
	ASSERT(SHT_ITER_ERR(iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(SHT_ITER_MSG(iter), "Iterator at beginning or end") == 0);

	SHT_ITER_FREE(iter);
	sht_free(ht);
}

TEST(iterator_error_messages)
{
	struct sht_ht *ht;
	struct sht_ro_iter *ro_iter;
	struct sht_rw_iter *rw_iter;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	e.key = 42;
	e.value = 100;
	ASSERT(sht_add(ht, &key, &e) == 0);

	/* Test read-only iterator error messages */
	ro_iter = sht_ro_iter(ht);
	ASSERT(ro_iter != NULL);

	e.value = 200;
	ASSERT(!SHT_ITER_REPLACE(ro_iter, &e));
	ASSERT(SHT_ITER_ERR(ro_iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(SHT_ITER_MSG(ro_iter), "Iterator at beginning or end") == 0);

	SHT_ITER_FREE(ro_iter);

	/* Test read/write iterator error messages */
	rw_iter = sht_rw_iter(ht);
	ASSERT(rw_iter != NULL);

	ASSERT(!sht_iter_delete(rw_iter));
	ASSERT(SHT_ITER_ERR(rw_iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(SHT_ITER_MSG(rw_iter), "Iterator at beginning or end") == 0);

	e.value = 300;
	ASSERT(!SHT_ITER_REPLACE(rw_iter, &e));
	ASSERT(SHT_ITER_ERR(rw_iter) == SHT_ERR_ITER_NO_LAST);
	ASSERT(strcmp(SHT_ITER_MSG(rw_iter), "Iterator at beginning or end") == 0);

	SHT_ITER_FREE(rw_iter);
	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Edge cases and stress tests
 *
 ******************************************************************************/

TEST(delete_and_readd)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i, key;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	/* Add, delete, and re-add entries multiple times */
	for (i = 0; i < 100; i++) {
		key = i % 10;
		e.key = key;
		e.value = i;

		if (i % 3 == 0 && sht_get(ht, &key) != NULL) {
			ASSERT(sht_delete(ht, &key));
		}

		int result = sht_add(ht, &key, &e);
		ASSERT(result == 0 || result == 1);
	}

	sht_free(ht);
}

TEST(wraparound_deletion)
{
	struct sht_ht *ht;
	struct int_entry e;
	int i;

	/* Use bad hash to force entries at end of table */
	ht = SHT_NEW(bad_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 8));

	/* Fill table to force wraparound */
	for (i = 0; i < 6; i++) {
		e.key = i;
		e.value = i * 10;
		ASSERT(sht_add(ht, &e.key, &e) == 0);
	}

	/* Delete entries to test wraparound shifting */
	for (i = 0; i < 6; i += 2) {
		ASSERT(sht_delete(ht, &i));
	}

	/* Verify remaining entries */
	for (i = 0; i < 6; i++) {
		const struct int_entry *r = sht_get(ht, &i);
		if (i % 2 == 0) {
			ASSERT(r == NULL);
		} else {
			ASSERT(r != NULL);
			ASSERT(r->value == i * 10);
		}
	}

	sht_free(ht);
}

TEST(string_keys)
{
	struct sht_ht *ht;
	struct str_entry e;
	const struct str_entry *result;
	const char *keys[] = {"foo", "bar", "baz", "qux"};
	int i;

	ht = SHT_NEW(str_hashfn, str_eqfn, struct str_entry);
	ASSERT(ht != NULL);
	sht_set_freefn(ht, str_freefn, NULL);
	ASSERT(sht_init(ht, 0));

	for (i = 0; i < 4; i++) {
		e.key = strdup(keys[i]);
		e.value = strdup("value");
		ASSERT(sht_add(ht, keys[i], &e) == 0);
	}

	for (i = 0; i < 4; i++) {
		result = sht_get(ht, keys[i]);
		ASSERT(result != NULL);
		ASSERT(strcmp(result->key, keys[i]) == 0);
	}

	sht_free(ht);
}

/*******************************************************************************
 *
 *	Tests: Abort conditions
 *
 ******************************************************************************/

TEST(abort_invalid_error_code)
{
	ASSERT_ABORTS(sht_msg(SHT_ERR_COUNT), "Invalid error code");
}

TEST(abort_ealign_not_power_of_2)
{
	ASSERT_ABORTS(sht_new_(int_hashfn, int_eqfn, sizeof(struct int_entry), 3, NULL),
		      "ealign not a power of 2");
}

TEST(abort_esize_ealign_incompatible)
{
	ASSERT_ABORTS(sht_new_(int_hashfn, int_eqfn, 10, 8, NULL),
		      "Incompatible values of esize and ealign");
}

TEST(abort_null_hashfn)
{
	ASSERT_ABORTS(sht_new_(NULL, int_eqfn, sizeof(struct int_entry),
			       _Alignof(struct int_entry), NULL),
		      "hashfn must not be NULL");
}

TEST(abort_null_eqfn)
{
	ASSERT_ABORTS(sht_new_(int_hashfn, NULL, sizeof(struct int_entry),
			       _Alignof(struct int_entry), NULL),
		      "eqfn must not be NULL");
}

TEST(abort_set_hash_ctx_after_init)
{
	struct sht_ht *ht;
	int ctx = 1;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT_ABORTS(sht_set_hash_ctx(ht, &ctx), "already initialized");

	sht_free(ht);
}

TEST(abort_set_eq_ctx_after_init)
{
	struct sht_ht *ht;
	int ctx = 1;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT_ABORTS(sht_set_eq_ctx(ht, &ctx), "already initialized");

	sht_free(ht);
}

TEST(abort_set_freefn_after_init)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT_ABORTS(sht_set_freefn(ht, ctx_freefn, NULL), "already initialized");

	sht_free(ht);
}

TEST(abort_set_lft_after_init)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT_ABORTS(sht_set_lft(ht, 50), "already initialized");

	sht_free(ht);
}

TEST(abort_set_lft_invalid_low)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_set_lft(ht, 0), "Invalid load factor");

	free(ht);
}

TEST(abort_set_lft_invalid_high)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_set_lft(ht, 101), "Invalid load factor");

	free(ht);
}

TEST(abort_set_psl_thold_after_init)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT_ABORTS(sht_set_psl_limit(ht, 100), "already initialized");

	sht_free(ht);
}

TEST(abort_set_psl_thold_invalid_low)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_set_psl_limit(ht, 0), "Invalid PSL threshold");

	free(ht);
}

TEST(abort_set_psl_thold_invalid_high)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_set_psl_limit(ht, 128), "Invalid PSL threshold");

	free(ht);
}

TEST(abort_init_twice)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));

	ASSERT_ABORTS(sht_init(ht, 0), "already initialized");

	sht_free(ht);
}

TEST(abort_size_not_initialized)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_size(ht), "not initialized");

	free(ht);
}

TEST(abort_empty_not_initialized)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_empty(ht), "not initialized");

	free(ht);
}

TEST(abort_get_not_initialized)
{
	struct sht_ht *ht;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_get(ht, &key), "not initialized");

	free(ht);
}

TEST(abort_add_not_initialized)
{
	struct sht_ht *ht;
	struct int_entry e = { .key = 42, .value = 100 };
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_add(ht, &key, &e), "not initialized");

	free(ht);
}

TEST(abort_set_not_initialized)
{
	struct sht_ht *ht;
	struct int_entry e = { .key = 42, .value = 100 };
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_set(ht, &key, &e), "not initialized");

	free(ht);
}

TEST(abort_replace_not_initialized)
{
	struct sht_ht *ht;
	struct int_entry e = { .key = 42, .value = 100 };
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_replace(ht, &key, &e), "not initialized");

	free(ht);
}

TEST(abort_swap_not_initialized)
{
	struct sht_ht *ht;
	struct int_entry e = { .key = 42, .value = 100 };
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_swap(ht, &key, &e, &e), "not initialized");

	free(ht);
}

TEST(abort_pop_not_initialized)
{
	struct sht_ht *ht;
	struct int_entry e;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_pop(ht, &key, &e), "not initialized");

	free(ht);
}

TEST(abort_delete_not_initialized)
{
	struct sht_ht *ht;
	int key = 42;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_delete(ht, &key), "not initialized");

	free(ht);
}

TEST(abort_ro_iter_not_initialized)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_ro_iter(ht), "not initialized");

	free(ht);
}

TEST(abort_rw_iter_not_initialized)
{
	struct sht_ht *ht;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);

	ASSERT_ABORTS(sht_rw_iter(ht), "not initialized");

	free(ht);
}

TEST(abort_add_with_iterator)
{
	struct sht_ht *ht;
	struct sht_ro_iter *iter;
	struct int_entry e = { .key = 1, .value = 10 };
	struct int_entry e2 = { .key = 2, .value = 20 };
	int key1 = 1, key2 = 2;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));
	ASSERT(sht_add(ht, &key1, &e) == 0);

	iter = sht_ro_iter(ht);
	ASSERT(iter != NULL);

	ASSERT_ABORTS(sht_add(ht, &key2, &e2), "iterator");

	SHT_ITER_FREE(iter);
	sht_free(ht);
}

TEST(abort_set_with_iterator)
{
	struct sht_ht *ht;
	struct sht_ro_iter *iter;
	struct int_entry e = { .key = 1, .value = 10 };
	struct int_entry e2 = { .key = 2, .value = 20 };
	int key1 = 1, key2 = 2;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));
	ASSERT(sht_add(ht, &key1, &e) == 0);

	iter = sht_ro_iter(ht);
	ASSERT(iter != NULL);

	ASSERT_ABORTS(sht_set(ht, &key2, &e2), "iterator");

	SHT_ITER_FREE(iter);
	sht_free(ht);
}

TEST(abort_pop_with_iterator)
{
	struct sht_ht *ht;
	struct sht_ro_iter *iter;
	struct int_entry e = { .key = 1, .value = 10 };
	struct int_entry popped;
	int key = 1;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));
	ASSERT(sht_add(ht, &key, &e) == 0);

	iter = sht_ro_iter(ht);
	ASSERT(iter != NULL);

	ASSERT_ABORTS(sht_pop(ht, &key, &popped), "iterator");

	SHT_ITER_FREE(iter);
	sht_free(ht);
}

TEST(abort_delete_with_iterator)
{
	struct sht_ht *ht;
	struct sht_ro_iter *iter;
	struct int_entry e = { .key = 1, .value = 10 };
	int key = 1;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));
	ASSERT(sht_add(ht, &key, &e) == 0);

	iter = sht_ro_iter(ht);
	ASSERT(iter != NULL);

	ASSERT_ABORTS(sht_delete(ht, &key), "iterator");

	SHT_ITER_FREE(iter);
	sht_free(ht);
}

TEST(abort_free_with_iterator)
{
	struct sht_ht *ht;
	struct sht_ro_iter *iter;
	struct int_entry e = { .key = 1, .value = 10 };
	int key = 1;

	ht = SHT_NEW(int_hashfn, int_eqfn, struct int_entry);
	ASSERT(ht != NULL);
	ASSERT(sht_init(ht, 0));
	ASSERT(sht_add(ht, &key, &e) == 0);

	iter = sht_ro_iter(ht);
	ASSERT(iter != NULL);

	ASSERT_ABORTS(sht_free(ht), "iterator");

	SHT_ITER_FREE(iter);
	sht_free(ht);
}

/*******************************************************************************
 *
 *	Main test runner
 *
 ******************************************************************************/

int main(void)
{
	printf("=== Hash Table Comprehensive Test Suite ===\n\n");

	/* Basic creation and initialization */
	RUN_TEST(create_and_free);
	RUN_TEST(create_without_err_pointer);
	RUN_TEST(create_with_capacity);
	RUN_TEST(entry_size_too_large);
	RUN_TEST(entry_size_maximum);
	RUN_TEST(capacity_too_large);
	RUN_TEST(unusual_alignment);

	/* Table state query operations */
	RUN_TEST(size_empty_table);
	RUN_TEST(size_with_entries);
	RUN_TEST(size_after_delete);
	RUN_TEST(empty_initial_table);
	RUN_TEST(empty_with_entries);
	RUN_TEST(empty_after_clear);

	/* Context and configuration */
	RUN_TEST(hash_context);
	RUN_TEST(eq_context);
	RUN_TEST(free_context);
	RUN_TEST(load_factor_threshold);
	RUN_TEST(psl_threshold);

	/* Add operations */
	RUN_TEST(add_new_entry);
	RUN_TEST(add_duplicate_entry);
	RUN_TEST(add_multiple_entries);

	/* Set operations */
	RUN_TEST(set_new_entry);
	RUN_TEST(set_replace_entry);
	RUN_TEST(set_with_freefn);

	/* Get operations */
	RUN_TEST(get_existing_entry);
	RUN_TEST(get_nonexistent_entry);

	/* Replace operations */
	RUN_TEST(replace_existing_entry);
	RUN_TEST(replace_nonexistent_entry);

	/* Swap operations */
	RUN_TEST(swap_existing_entry);
	RUN_TEST(swap_nonexistent_entry);
	RUN_TEST(swap_separate_buffers);

	/* Delete operations */
	RUN_TEST(delete_existing_entry);
	RUN_TEST(delete_nonexistent_entry);
	RUN_TEST(pop_existing_entry);
	RUN_TEST(pop_nonexistent_entry);

	/* Table growth and collision handling */
	RUN_TEST(table_growth);
	RUN_TEST(collision_handling);
	RUN_TEST(excessive_collisions);
	RUN_TEST(excessive_collisions_psl_10);
	RUN_TEST(excessive_collisions_psl_50);
	RUN_TEST(excessive_collisions_psl_1);
	RUN_TEST(psl_tracking_after_delete);

	/* Read-only iterators */
	RUN_TEST(ro_iterator_empty_table);
	RUN_TEST(ro_iterator_all_entries);
	RUN_TEST(multiple_ro_iterators);
	RUN_TEST(ro_iterator_max_count);
	RUN_TEST(ro_iterator_replace);

	/* Read/write iterators */
	RUN_TEST(rw_iterator_empty_table);
	RUN_TEST(rw_iterator_exclusive);
	RUN_TEST(ro_iterator_blocks_rw);
	RUN_TEST(rw_iterator_delete);
	RUN_TEST(rw_iterator_replace);
	RUN_TEST(iterator_delete_no_last);
	RUN_TEST(iterator_replace_no_last);
	RUN_TEST(iterator_error_messages);

	/* Edge cases and stress tests */
	RUN_TEST(delete_and_readd);
	RUN_TEST(wraparound_deletion);
	RUN_TEST(string_keys);

	/* Abort conditions */
	RUN_TEST(abort_invalid_error_code);
	RUN_TEST(abort_ealign_not_power_of_2);
	RUN_TEST(abort_esize_ealign_incompatible);
	RUN_TEST(abort_null_hashfn);
	RUN_TEST(abort_null_eqfn);
	RUN_TEST(abort_set_hash_ctx_after_init);
	RUN_TEST(abort_set_eq_ctx_after_init);
	RUN_TEST(abort_set_freefn_after_init);
	RUN_TEST(abort_set_lft_after_init);
	RUN_TEST(abort_set_lft_invalid_low);
	RUN_TEST(abort_set_lft_invalid_high);
	RUN_TEST(abort_set_psl_thold_after_init);
	RUN_TEST(abort_set_psl_thold_invalid_low);
	RUN_TEST(abort_set_psl_thold_invalid_high);
	RUN_TEST(abort_init_twice);
	RUN_TEST(abort_size_not_initialized);
	RUN_TEST(abort_empty_not_initialized);
	RUN_TEST(abort_get_not_initialized);
	RUN_TEST(abort_add_not_initialized);
	RUN_TEST(abort_set_not_initialized);
	RUN_TEST(abort_replace_not_initialized);
	RUN_TEST(abort_swap_not_initialized);
	RUN_TEST(abort_pop_not_initialized);
	RUN_TEST(abort_delete_not_initialized);
	RUN_TEST(abort_ro_iter_not_initialized);
	RUN_TEST(abort_rw_iter_not_initialized);
	RUN_TEST(abort_add_with_iterator);
	RUN_TEST(abort_set_with_iterator);
	RUN_TEST(abort_pop_with_iterator);
	RUN_TEST(abort_delete_with_iterator);
	RUN_TEST(abort_free_with_iterator);

	/* Summary */
	printf("\n=== Test Summary ===\n");
	printf("Tests run:    %u\n", tests_run);
	printf("Tests passed: %u\n", tests_passed);
	printf("Tests failed: %u\n", tests_failed);

	if (tests_failed == 0) {
		printf("\nAll tests PASSED!\n");
		return 0;
	} else {
		printf("\nSome tests FAILED!\n");
		return 1;
	}
}
